#!/usr/bin/perl -T

##################
# SETUP:
#   
#   PATH in system where we save hardlink on the received email by QMAIL
#   my $path="/big/cassandra";
#   
#   Script which call Celery 'task' {insert email into DB and fulltext engine
#   system("python /var/spool/qscan/cassandraClient.py $hlinkEmail &");
#
#


#
# File: qmail-scanner-queue.pl
# Version: 2.08 - st - patch - 20100626
#
# Author: Jason L. Haar <jhaar - users.sourceforge.net>
# 
# Patch by: Salvatore Toribio <toribio - pusc.it>
#
# See the file README-st-patch for information about the patch
# This version deletes/rejects spam based in Chris Hine's patch for v1.16
#
# Each user could has his own scanners and sa_settings.
# 
# This file was auto-generated by:
#
# ./configure --qs-user qscand --admin mailer-daemon --domain virusfree.cz --admin-description "www.virusfree.cz Contact your local support" --notify psender --local-domains virusfree.cz --silent-viruses auto --virus-to-delete 0 --skip-text-msgs 1 --lang en_GB --debug 1 --add-dscr-hdrs 0 --dscr-hdrs-text "www.virusfree.cz" --normalize 1 --archive 0 --settings-per-domain 1 --max-scan-size 100000000 --unzip 1 --max-zip-size 1000000000 --max-unpacked-files 10000 --redundant 0 --log-details yes --log-crypto yes --fix-mime 2 --ignore-eol-check 1 --sa-tempfail 0 --sa-faulttolerant 0 --sa-timeout 100 --sa-subject "SPAM *** " --sa-delta 0 --sa-alt 1 --sa-debug 1 --sa-report 0 --sa-quarantine 13 --sa-delete 13 --sa-reject 0 --scanners "auto"
#
# Scanners installed = ("clamdscan_scanner","fpscan_scanner","fpscand_scanner","spamassassin","perlscan_scanner")
# 
# Description: This is a replacement/add-on for Qmail 1.0.3's qmail-queue.
# It can call several blocking programs - such as virus scanners - on every 
# SMTP-received Email message, checking for viruses and blocked filenames, 
# only allowing the message to continue if it passes the tests.
#
#   Copyright (C) 1999,2000-2010 the people mentioned above
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 1, or (at your option)
#   any later version. See <URL:http://www.gnu.org/copyleft/gpl.html>
#   for a copy.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   The software is provided as is. Please bear in mind that we have 
#   done this in my spare time. While it is as accurate as we could 
#   make it there is a reasonable chance that there are mistakes 
#   somewhere in here. If you email me and tell me about them, I will 
#   be happy to fix them but I can't take responsibility for your system. 
#   Basically use this at your own risk. 
#
#####################################################################

#####################################################################
##
## Required Packages
##
## Qmail-1.03
## Perl 5.005_03+
## Maildrop-0.73
## Bruce Guenter's QMAILQUEUE patch <URL:http://www.qmail.org/qmailqueue-patch>
## Perl module Time::HiRes and DB_File
##
##
## So-far tested Virus scanners:
##     Trend's Virus scanner for Linux
##     MacAfee's (NAI's) virus scanner for Linux
##     Sophos's virus scanner for Linux
##     H+BEDV's antivir scanner for Linux
##     F-Secure's fsav scanner for Linux
##     P-Prot for Linux
##     Sophie (daemonized Sophos scanner)
##     Trophie (daemonized Trend scanner)
##     ...and more - see README for full list
## 
#####################################################################

#####################################################################
##
## Site-specific config
##
#####################################################################


delete @ENV{qw(IFS CDPATH ENV BASH_ENV QMAILMFTFILE QMAILINJECT)};

use strict 'vars', 'subs';

#Set locale to "C" (English). That way any string checks on forked apps 
#will tend to be in English - simplifying/standardizing regex matches
my $orig_locale=$ENV{'LC_ALL'};
$ENV{'LC_ALL'}= $ENV{'LANG'} = $ENV{'LANGUAGE'} = 'C';
POSIX::setlocale(&POSIX::LC_ALL,'C');

use Sys::Syslog qw(:DEFAULT setlogsock);
setlogsock('unix');

my $VERSION="2.08";
my $st_version="20100626";
$VERSION.='VF';

#Mail header to add to each scanned message to report stuff in...
#Default is to not generate them ($descriptive_hdrs = 0) - as  that
#info is also in the Received: headers...
my $descriptive_hdrs=0;
my $V_HEADER="localhost";
my($qsmsgid);
$qsmsgid=tolower("$V_HEADER-message-id");

my ($generateMsgID);


my($qscan_account)='qscand';

#From: line  information used when making reports
my $V_FROM='';
my $V_FROMNAME='Contact your local support';

# Address carbon-copied on any virus reports
my $QUARANTINE_CC='';

#Array of local domains that are checked against for
#deciding whether or not to send recipient alerts to
my @local_domains_array=('localhost');

# Array of virus that we don't want to inform the sender of.
my @silent_viruses_array=('klez','bugbear','hybris','yaha','braid','nimda','tanatos','sobig','winevar','palyh','fizzer','gibe','cailont','lovelorn','swen','dumaru','sober','hawawi','hawaii','holar-i','mimail','poffer','bagle','worm.galil','mydoom','worm.sco','tanx','novarg','@mm','cissy','cissi','qizy','bugler','dloade','netsky','spam');

# st: Virus that will be deleted without notifying anyone,
# you can add other viruses in the form "virus1|virus2|virus3".
# Most of the viruses in the 'silent_viruses_array' could be
# added to this list safely.
# i.e. "mydoom|worm.sco|novarg|tanx|bagle|netsky|somefool|roca|agobot|dumaru|sober|lovgate|klez|rox|zafi|(PIF|SCR|CPL) files|mybot|mabutu"
my $virus_to_delete="virus|worm|viagra|HTML|w32";

#Array of virtual headers used within perlscanner 
my @virtualheaders_array=("MAILFROM","RCPTTO","REMOTEIPADDR","ZIPPASSWORDPROTECTED","ISSENSITIVEANDNOCRYPTO","CRYPTODETAILS","FILELENGTHTOOLONG","FILEDOUBLEBARRELED","FILECLSID");

#Addresses that should be alerted of any quarantined Email
my $NOTIFY_ADDRS='psender';

#Try to fix bad MIME messages before passing to MIME unpacker
my $BAD_MIME_CHECKS='2';

#Block password protected zip files
#my $BLOCK_PASSWORD_PROTECTED_ARCHIVES='QUARANTINE_PASSWORD_PROTECTED';

#Disable just the EOL char check instead of all of BAD_MIME_CHECKS
my $IGNORE_EOL_CHECK='1';

# The full path to qmail programs we'll need.
my $qmailinject = '/var/qmail/bin/qmail-inject';
my $qmailqueue  = '/var/qmail/bin/qmail-basket';
# Alternative qmail queue for delivering messages which has been tagged as spam and are not rejected
my $qmailqueue2  = $qmailqueue;

# What directory to use for storing temporary files.
my $scandir = '/var/spool/qscan';

#Where the Q-S configs are
my $configdir = '/var/spool/qscan';

#Where the Q-S logs live
my $logdir = '/var/spool/qscan';

#What maildir folder to store working files in
my $wmaildir='working';

#What maildir folder to store virus-infected msgs in
my $vmaildir='viruses';

#What maildir folder to store policy-blocked msgs in
my $pmaildir='policy';

#What maildir folder to store high-scoring SPAM in (instead of passing it on)
#NOTE: this only gets used if $sa_quarantine_site is set 
# st: see below '$smaildir_site'
#my $smaildir='spam';

#What maildir folder to archive received Email in instead of deleting
my $archiveit='0';
my $archivedir='archives';

#Name of file in $logdir where debugging output goes
my $debuglog="qmail-queue.log";

#Name of file where quarantine reports go (for long-term storage)
my $quarantinelog="quarantine.log";

#Generate nice random filename
my ($sysname, $hostname, $release, $version, $machine) = uname();
#my $hostname='bq'; #could get via call I suppose...

#If you trust the virus scanners handling of mbox format itself
#you may want to let it have a go at the "raw" message, and original
#zip files if present
my $redundant_scanning='0';

#If you want to log via file/syslog information of all Email
# that passes through your system (from/to/subj/size/attachments)
my $log_details="details";

#If you'd like Q-S to report which messages are PGP or S/MIME,
#turn this on
my $log_crypto="yes";

#Max size of message allowed to be scanned - 100Mbytes by default 
#DO NOT SET LOWER THAN 10Mbytes!!!!!
my $MAX_SCAN_SIZE=100000000;

#bypass all AV/Spam scanning - but still do perlscan checks
my $SKIP_SCANNING=0;

# st: If $sa_subject is defined and fast_spamassassin mode is selected,
# a tag will be added to the subject indicating how the message is to
# be considered as spam, in this way:
# LOW: required_hits < score < required_hits + sa_delta
# MEDIUM: required_hits + sa_delta < score < required_hits + 2 * sa_delta
# HIGH: required_hits + 2 * sa_delta < score
# Be aware, 2*sa_delta must be lower than sa_quarantine.
# 'required_hits' is the value set in the SpamAssassin configuration file.
my $sa_delta_site='0';

# st: Spam messages with a score higher than
# (required_hits + sa_quarantine) should be quarantined.
# Only relevant if SpamAssassin is used.
# Score of 0 means deliver all messages. Defaults to 0.
my $sa_quarantine_site='0';

# st: Some people wants to quarantine spam in a different
# maildir folder than viruses, maybe to run sa-learn.
# The default is:
# my $smaildir_site='spam'; 
# You can set it per user/domain in the file 'settings_per_domain.txt'
# WARNING: if $smaildir it is not in the same 'file system' (partition)
# than $wmaildir, you have to change the routine 'sub email_quarantine_report'
# you will find the code commented in that routine.
# (in the official version 2.00 this setting has been added)
my $smaildir_site='spam';

# st: address to send a copy of the mails 'quarantined'
# as spam for admin puropose (I thought), almost unmodifyed.
# Enable $sa_fwd_verbose if you want the X-Spam headers in
# the forwarded message.
my $sa_forward_site='';
my $sa_fwd_verbose_site='0';

# st: Spam messages with a score higher than
# (required_hits + sa_delete) should be deleted (or rejected).
# Only relevant if SpamAssassin is used. Score of 0
# means deliver all messages. Defaults to 0.
# If sa-quarantine is set, sa-delete must be greater.
my $sa_delete_site='0';

# st: If you enable sa-reject and sa-delete is properly set,
# messages with a score higher than (required_hits + sa_delete)
# will be rejected before the smtp session is closed.
# Otherwise they are just dropped silently. (1/0)
# Similar for the official version option $QUARANTINE_REJECT_STATUS
# But only rejects spam.
my $sa_reject_site='1';

#The exit code is different for vanilla qmail vs custom error patched...
my $QUARANTINE_REJECT_EXITCODE="31";
my $REJECT_FD='6';

# st: Use the alternative subroutine for spamassassin, it runs
# ALWAYS in *fast_spamassassin* mode and doesn't pass the '-u' option
# to spamc. So if you want to run in *verbose_spamassasin* mode or you
# want to use the sql per user preferences for spamassassin, you have
# to disable this option and run the standard spamassassin routine.
# It also allows to log the spamassassin report. (1/0)
my $sa_alt='1';

# st: If sa_alt is enabled an you enable this option, you will
# have a beautiful log with the tests and the scores of
# spamassassin in the file qmail-queue.log, and you
# can add the X-Spam-Report header enabling the
# option below. (1/0)
my $sa_debug='1';

# st: If sa_alt is enabled, *qmail-scanner* will
# add the X-Spam-Report header to the messages if you
# enable this option. (1/0)
my $sa_hdr_report_site='0';

# st: Enable this option to do not pass to spamassassin messages
# from MAILER-DAEMON, see READMEpatched for details. (1/0)
my $SA_SKIP_MD='0';

##############################################
# st: SETTINGS PER DOMAIN
##############################################

# st: Enable or diasable scanner per domain (1/0)
my $settings_pd='1';

# Array of virus scanners used must point to subroutines
my @scanner_array=();

# st: @scanners_installed is the array with all scanners installed
# in the computer, if you disable $settings_pd qmail-scanner will fall to
# this array. Don't modify it unless you really know what you do.
my @scanners_installed=("perlscan_scanner");

# st: @scanners_default if $settings_pd is enabled qmail-scanner will
# use this array for the users/domains that don't have a custom
# scanner_array set  in the $settings_per_domain.txt file.
# You can set it to "none" to skip all the scanners, even perlscan.
# If you want to skip the scanners only for a particular user/domain
# set his scanners list to "none" in the $settings_per_domain.txt file.
my @scanners_default=("perlscan_scanner");

# st: DB file (without extension) where per domain/user scanners
# are saved, edit $settings_per_domain.txt and run
# "qmail-scanner-queue.pl -p" to generate $settings_per_domain.db
my $settings_per_domain="$configdir/settings_per_domain";

# st: if spamassassin has sql user settings, then run spamassassin
# per each recipient. Again verbose_spamassassin is a pain, so sa_alt will
# be run after the first recipient. (1/0)
my $sa_sql='0';

# dns query base
my $spddns_base = "";

# dns query timeout
my $spddns_timeout = 2;

my $spddns_ext = "";

##############################################
# The following variable MUST NOT be modified, qmail-scanner will set
# them by its own for each recipient.
my $domain_returnpath='';
my $domain_one_recip='';
my $sa_rcpt='0';
my (%found_event);
#
my $sa_subject='';
my $sa_quarantine='';
my $sa_delta='';
my $sa_delete='';
my $sa_reject='';
my $sa_forward='';
my $sa_fwd_verbose='';
my $sa_hdr_report='';
my $smaildir='';
##############################################

#Full path to file in which virus-scanner versioning info is kept
my $versionfile="$configdir/qmail-scanner-queue-version.txt";

#DB file (without extension) where bad filenames are kept.
# You edit $db_filename.txt, and "qmail-scanner-queue.pl -g" generates $db_filename.db
my $db_filename="$configdir/quarantine-events";

# st: configurable in st-patch
# This rule exists but is never 
# expected to trigger normally (defaults 10,000, is stupidly high). 
my $MAX_NUM_UNPACKED_FILES='10000';

#What locale is used on this system
#$sys_locale="LOCALE";

#Full paths to binaries used within this script follow - small performance
#improvement :-)


my $mimeunpacker_binary='/usr/bin/reformime ';
my $unzip_binary='/usr/bin/unzip';
my $unzip_options='-Pxx466131335xx';
my $max_zip_size='1000000000';
my $tnef_binary='/usr/bin/tnef';
my $rm_binary='/bin/rm';
my $grep_binary='/bin/grep';
my $find_binary='/usr/bin/find';
my $uudecode_binary='/usr/bin/uudecode';
my $uudecode_pipe='-o -';


my $uvscan_binary='';
my $csav_binary='';
my $nod32_binary='';
my $nod32upd_binary='';
my $esets_binary='';
my $sweep_binary='';
my $savscan_binary='';
my $sophie_binary='';
my $trophie_binary='';
my $iscan_binary='';
my $hbedv_binary='';
my $hbedv_options='';
my $avp_binary='';
my $avpdaemon_binary='';
my $fpscan_binary='/usr/local/bin/fpscan';
my $fpscand_binary='/usr/local/sbin/fpscand';
my $fsecure_binary='';
my $inocucmd_binary='';
my $ravlin_binary='';
my $vexira_binary='';
my $bitdefender_binary='';
my $clamscan_binary='/usr/bin/clamscan';
my $clamscan_options="-r --no-summary --max-scansize=50M --max-recursion=10";
my $clamdscan_binary='/usr/bin/clamdscan';
my $clamdscan_options="--no-summary";
my $freshclam_binary='/usr/bin/freshclam';
my $avastlite_binary='';
my $avastcmd_binary='';

# st: I have returned to my own way to set the  (1.25st)
my $spamc_binary='/usr/bin/spamc';
my $sa_timeout='100';
my $sa_maxsize='256000';

# st: whether or not to run spamassassin in  fast or verbose mod
# remember that the routine sa_alt always set sa_fast to 1, by her own.
# Please run in fast mode, you can break the verbose mode with your personal
# local.cf, so better run in fast mode (If you like SA REPORT read the docs).
#my $spamc_options='SPAMC_OPTIONS';
my $sa_fast='1';

my $sa_subject_site="SPAM *** ";  # st: if fast_spamassassin mode is selected
my $spamassassin_binary='/usr/bin/spamassassin ';
my $sa_tempfail='0';
my ($sa_comment,$sa_level);
my ($sa_ft)='0';
my $sa_symbol='*';
my ($tag_score,$tag_sa_score);

$spamc_binary.=" -t $sa_timeout" if ($sa_timeout ne "");
$spamc_binary.=" -s $sa_maxsize" if ($sa_maxsize ne "");

# st: If somebody is using spamassassin with unix socket...
my $spamd_socket='';
$spamc_binary.=" -U $spamd_socket" if ($spamd_socket ne "");

my $SNEAKY_WINDOWS_EXTENSIONS="exe|w[pm][szd]|vcf|nws|cmd|bat|pif|sc[rt]|dll|ocx|do[ct]|xl[swt]|p[po]t|pps|vb[se]?|hta|p[lm]|sh[bs]|hlp|chm|ws[cfh]|ad[ep]|jse?|md[abew]|ms[ip]|reg|as[dfx]|cil|cpl";
my $VALID_WINDOWS_EXTENSIONS="rtf|pdf|sav|htm|html|pst|ost|txt|gif|jpeg|mpeg|jpg|png|mny|wav|tif|$SNEAKY_WINDOWS_EXTENSIONS";
my $passwd_protected_zip;

#Little workaround. Apparently people send docs of the form "my.domainname.com.doc" - so you can get false positives
#due to ".com". So don't add  ".com" to SNEAKY_WINDOWS_EXTENSIONS until after VALID_WINDOWS_EXTENSIONS is defined
#So now "file.com.tif" won't trigger, but file.tif.com will.
$SNEAKY_WINDOWS_EXTENSIONS="$SNEAKY_WINDOWS_EXTENSIONS|com";


$ENV{'PATH'}='/bin:/usr/bin';

my $SCANINFO='';

my $MAX_FILE_LENGTH=100;
my $MAX_NUM_HDRS=140;
my $QE_LEN=20;

#Maximum amount of time we allow Q-S to run before returning
# a temp failure. This is so remote SMTP servers don't get confused
# over whether or not they have delivered to a SMTP server
# that's refused to say "OK" for over an hour...
# We'll default to 20 minutes. If the scanner loop takes more than 20 
# minutes to scan the message, then something *must* be wrong with the
# scanner. 
my $MAXTIME=7*60;

#Finally, are you sure your virus scanners can unpack zip files? 
#Turn this on to force Qmail-Scanner to unzip for you
my $force_unzip=1;

#Descriptive string to use in generated Email
my $destring="virus";

#####################################################################
## 
## End of site-specific settings
##
#####################################################################

# st: minidebug has been moved to debug(level)
#   1 - only important info is logged
#   2-3-4 more info is logged...
#   5 - all the info is logged (same as set debug to 1 in the official version)
#   >100 the temporary files are not removed
#

#Want debugging? Enable this and read $logdir/qmail-queue.log
my $DEBUG='5';

my @uufile_list = ();
my @attachment_list = ();
my @zipfile_list = ();

#Want microsec times for debugging
use Time::HiRes qw( usleep ualarm gettimeofday tv_interval );
use File::Copy;
use POSIX;
use DB_File;

use vars qw/ $opt_v $opt_V $opt_h $opt_g $opt_r $opt_z $opt_p $opt_d $opt_s/;

use Getopt::Std;

#my ($opt_v,$opt_h,$opt_g,$opt_r,$opt_z);

getopts('vVhgrzpds');

my ($start_time,$last_time);
$start_time = $last_time = [gettimeofday];

(my $prog=$0) =~ s/^.*\///g;

if ( $opt_h ) {
  print "

 $prog  $VERSION-$st_version

    -h - This help
    -v - show details about this install. 
         Please include in any bug reports.
    -V - show details about this install
         and some configuration information.
    -z - gather virus scanner/DAT versions 
         and cleanup old temp files
    -g - generate perlscanner database
    -r - read from perlscanner database

    -p - generate settings per domain database
    -d - display settings per domain database
    -s - sort the text file $settings_per_domain.txt\n\n";
  exit;
}

# st: I need the localtime at this point for the routine read_spd
#Get current timestamp for logs
my ($sec,$min,$hour,$mday,$mon,$year,$nowtime);
($sec,$min,$hour,$mday,$mon,$year) = localtime(time);

if ( $opt_g || $opt_r) {
  &generate_quarantine_db;
  exit 0;
} elsif ($opt_p) {
  &generate_spd;
  exit 0;
} elsif ($opt_d || $opt_s) {
  &read_spd;
  exit 0;
} elsif ($opt_v || $opt_V) {
  &show_version;
  exit 0;
}


chdir($scandir);
umask(0007);

if (! -d "$scandir/tmp") {
  mkdir("$scandir/tmp",0750) || &error_condition("cannot create $scandir/tmp - $!");
}

my ($quarantine_event,$quarantine_event_tmp)=0;
my ($quarantine_DOS,$quarantine_spam)=0;

my $file_id = &uniq_id();

#For security reasons, tighten the follow vars...
$ENV{'SHELL'} = '/bin/sh' if exists $ENV{SHELL};
$ENV{'TMP'} = $ENV{'TMPDIR'} = "$scandir/tmp/$file_id";
#$ENV{'QMAILSUSER'} = $ENV{'QMAILSHOST'} = '';



if ($mimeunpacker_binary =~ /reformime/) {
  $mimeunpacker_binary .= " -x$ENV{'TMPDIR'}/";
} elsif ($mimeunpacker_binary =~ /ripmime/) {
   $mimeunpacker_binary .= " --unique_names --no-ole --paranoid -i - -d $ENV{'TMPDIR'}/";
}


my ($smtp_sender,$remote_smtp_ip,$remote_smtp_host,$remote_smtp_auth,$real_uid,$effective_uid);

$real_uid=$<;
$effective_uid=$>;

# st: I will need the process number, and other variables, later
my $nprocess=$$;
my $nppid=getppid;
if ($nppid == 1) {
   # The parent pid is dead, maybe a message with BLFs
   if ($DEBUG < 3) {
      warn "$V_HEADER-$VERSION: Process $nprocess closed, parent process died\n";
   } else {
      warn "$nprocess QS-$VERSION: Process $nprocess closed, parent process died\n";
   }
   exit 111;
}
$nprocess.="/$nppid" if ($DEBUG >= 2);
my $sa_report='';
my ($sa_hits,$required_hits)=('0','0');
# st: Flag to delete message
my $del_message='0';

if ($DEBUG) {
  ### PeO <peo - bsd-guide.net>: support of date and time formatting for log file name
  #my $debuglog = "qmail-queue-%Y-%m-%d.log";
  #$debuglog = strftime($debuglog, localtime(time)) if ($debuglog =~ /\%/);
  open(LOG,">>$logdir/$debuglog");
  select(LOG);$|=1;
  &debug("+++ starting debugging for process $$ (ppid=$nppid) by uid=$real_uid",1);
}

# st: if sa_alt is '0', sa_hdr_report_site must be 0
$sa_hdr_report_site='0' if ( !$sa_alt );

# st: if the variable BMC_WHITELIST is set in the tcpserver
# don't search for 'bad mime characters' in the headers of messages
# coming from those IPs.
# It would be hard to mantain this whitelist...
if (defined($ENV{'BMC_WHITELIST'})) {
  $BAD_MIME_CHECKS='0';
  &debug("WL: The server is in the BMC_WHITELIST, don't check BMC",1);
}


&debug("setting UID to EUID so subprocesses can access files generated by this script",5);
$< = $>;            # set real to effective uid
$( = $);            # set real to effective gid

&debug("program name is $prog, version $VERSION",5);
if ($opt_z) {
  &scan_queue;
  &close_log;
  exit 0;
}


&scanner_info;

my (%headers , %virtualheader);
my ($CRYPTO_TYPE,$DOMKEYS,$altered_subject, $HEADERS, $env_returnpath, $returnpath, $QS_RELAYCLIENT);
my ($ATTACHMENT, %BOUNDARY,$BOUNDARY_REGEX,$attachment_header,$attachment_value,%attach_hdrs,%content_type);
my ($ct_attachment_filename,$cd_attachment_filename);
my ($env_recips, $recips, $trecips, $recip, $one_recip);
my ($alarm_status,$elapsed_time,$msg_size,$file_desc);
my ($description,$quarantine_description,$illegal_mime);
my $skip_text_msgs=1;
my $plain_text_msg=0;
my $indicates_attachments=0;
my $xstatus=0;
my $attachment_counter=0;
my $rawsubject;

&working_copy;

&debug("w_c: message size $msg_size bytes",2);

#We will set our own value here as it allows us to unset
#it later without changing how Qmail actually interprets
#RELAYCLIENT
$QS_RELAYCLIENT=1 if (defined($ENV{'RELAYCLIENT'}));

if ($ENV{'TCPREMOTEIP'}) {
  $remote_smtp_ip=$ENV{'TCPREMOTEIP'};
  if ($ENV{'TCPREMOTEHOST'} ne "") {
    $remote_smtp_host=$ENV{'TCPREMOTEHOST'};
  }else{
    $remote_smtp_host=$remote_smtp_ip;
  }
  if ($ENV{'TCPREMOTEINFO'}) {
    $remote_smtp_auth=" (".$ENV{'TCPREMOTEINFO'}."\@$remote_smtp_host)";
    $smtp_sender="via SMTP from $remote_smtp_host using auth $remote_smtp_auth";
  }else{
    $smtp_sender="via SMTP from $remote_smtp_host";
  }
  $tag_score="RC:1($remote_smtp_ip):" if ($QS_RELAYCLIENT);
  &debug("incoming SMTP connection from $smtp_sender",5);
  #system("/usr/bin/printenv > /tmp/qmail-scanner.env");
  # st: do not reject mails from localhost useful for fetchmail
  $sa_reject="0" if ($remote_smtp_ip eq "127.0.0.1");
} else {
  $smtp_sender="via local process $$";
  $remote_smtp_ip='127.0.0.1';
  #Set QS_RELAYCLIENT if QS_SPAMASSASSIN isn't set
  $QS_RELAYCLIENT=1;
  $tag_score="RC:1($remote_smtp_ip):"; #Always would be relayed
  &debug("incoming pipe connection from $smtp_sender",5);
  # st: do not reject mails from localhost useful for fetchmail
  $sa_reject="0";
}
$tag_score="RC:0($remote_smtp_ip):" if ($tag_score !~ /^RC:1/);


#Now alarm this area so that hung networks/virus scanners don't cause 
#double-delivery...

eval {
  $SIG{ALRM} = sub { die "Maximum time exceeded. Something cannot handle this message." };
  alarm $MAXTIME;

  &deconstruct_msg; #JLH if (!$quarantine_event);
  
  
  #Now unset env var QMAILQUEUE so any further Email's sent don't
  #go through the Qmail-Scanner again
  &debug("unsetting QMAILQUEUE env var",5);
  delete $ENV{'QMAILQUEUE'};
  
  #This SMTP session is incomplete until we see dem envelope headers!
  &grab_envelope_hdrs;
  &debug("from='$headers{'from'}', subj='$headers{'subject'}', $smtp_sender",1);
  &debug("from=$headers{'from'},subj=$headers{'subject'}, $qsmsgid=$headers{$qsmsgid} $smtp_sender",5);

  ##### st: variables for settings per domain
  #$returnpath=tolower($returnpath);
  $domain_returnpath=&get_domain($returnpath);
  #
  #$one_recip=tolower($one_recip);
  $domain_one_recip=&get_domain($one_recip) if ($one_recip);
  ######

  #Add envelope details to headers array so that they can be matched within
  #perlscanner.
  #Note how they're uppercase cf the message headers which are all forced
  #lowercased. This is to ensure no-one can override them...

  $headers{'MAILFROM'}=$returnpath;
  $headers{'RCPTTO'}=$recips;
  $headers{'REMOTEIPADDR'}=$remote_smtp_ip;

  if ( ($BAD_MIME_CHECKS > 1 && $headers{'mime-version'} eq "") || ($headers{'mime-version'} ne "" && $headers{'content-type'} =~ /^text\/plain/i)) {
    #Hmm, doesn't look nice, but it feels better to make this a separate check for some reason
    if ($skip_text_msgs && ($indicates_attachments < 2) && !@uufile_list && !@attachment_list) {
      &debug("This is a PLAIN text message, skip virus scanners - but not SA",2);
      $plain_text_msg=1;
    }
  }
  if ($headers{'MAILFROM'} eq "" || $headers{'subject'} =~ /Returned mail:|Mail Transaction Failed/) {
    &debug("This is a bounce message - better assume there's an attachment in it",5);
    $plain_text_msg=0;
  }

##############################################
# st: SETTINGS PER DOMAIN 
# #X??? - hookup here
##############################################

  $quarantine_event_tmp=$quarantine_event;

#  if ($settings_pd && ( ! -f "$settings_per_domain.db")) {
#    &debug("s_p_d: $settings_per_domain.db doesn't exist falling to installed scanners",2);
#    $settings_pd='0';
#  }
  if ($settings_pd) {
    &settings_p_d;
  } else {
    @scanner_array=@scanners_installed;
    &sa_defaults;
    &start_scanners($env_returnpath,$env_recips,"$scandir/$wmaildir/new/$file_id");
    foreach (split(/\0T/,$trecips)) {
      $one_recip = $_;
      &log_event;
    }
  }

##############################################

  alarm 0;
};

$alarm_status=$@;
if ($alarm_status and $alarm_status ne "" ) { 
  if ($alarm_status eq "Maximum time exceeded. Something cannot handle this message.") {
    &error_condition("ALARM: taking longer than $MAXTIME secs. Requeuing...");
  } else {
    &error_condition("Requeuing: $alarm_status");
  }
}


#Msg has been delivered now, so don't want hangs in this part
#to affect delivery

#&log_event;

&cleanup;

# st: st-patch will only reject spam and there is a subroutine to do it...
#
## BE CAREFUL. I'm concerned for people running Q-S behind edge gateways.
## Those boxes would then generate a bounce (as they are not the actual SMTP client)
#if ($QUARANTINE_REJECT_STATUS && $quarantine_event) {
#  &debug("exit with permanent error: \"$quarantine_event\"",5);
#  #This string will only be seen on Qmail sites with the custom-error patch.
#  open (FD,">&6"); print FD "DMessage rejected: $quarantine_event"; close FD;
#  exit $QUARANTINE_REJECT_EXITCODE;
#}

# st: just for the script log-report, add the information of policy block to the log
if ($quarantine_event =~ /^(policy|perlscan)/i && $quarantine_event !~ /gr[ae]ylist/i && $quarantine_description) {
   &debug("q_s: Policy BLOCK",1);
}

# st: write to the log the end of the process
&close_log;
exit 0;

############################################################################
# Error handling
############################################################################

#Generate uniq identifiers
sub uniq_id {
  return "$hostname" . time .  __LINE__ . $$;
}


sub log_event {

  my $ts = $tag_score;
  if ($log_details) {
    $ts .= "$tag_sa_score" if ($tag_sa_score);
    $ts .= "OS:$ENV{'REMOTE_OS'}:" if ($ENV{'REMOTE_OS'} ne "");
    $ts .= "GeoIP:$ENV{'REMOTE_COUNTRY'}:" if ($ENV{'REMOTE_COUNTRY'} ne "");
    $ts .= "$CRYPTO_TYPE:" if ($log_crypto && $CRYPTO_TYPE ne "");
    $ts .= "$DOMKEYS:" if ($log_crypto && $DOMKEYS ne "");
    #$virtualheader{'CRYPTODETAILS'}="$CRYPTO_TYPE:$DOMKEYS";
    $ts = ":$ts" if ($ts ne "");

    if(scalar(@_) == 1) {
    	&log_msg("VF-scanner",($quarantine_event ne "0" ? "$quarantine_event$ts" : "Clear$ts"),$elapsed_time,$msg_size,$returnpath,$one_recip,$rawsubject,$headers{$qsmsgid},$file_desc, "1");
    } else {
        &log_msg("VF-scanner",($quarantine_event ne "0" ? "$quarantine_event$ts" : "Clear$ts"),$elapsed_time,$msg_size,$returnpath,$one_recip,$rawsubject,$headers{$qsmsgid},$file_desc);
    }
  }
}
# Fail with the given message and a temporary failure code.
sub error_condition {
  my ($string,$errcode)=@_;
  $errcode=111 if (!$errcode);
  eval {
    syslog('mail|err',"$V_HEADER-$VERSION:[$file_id] $string");
  };
  if ($@) {
    setlogsock('inet');
    syslog('mail|err',"$V_HEADER-$VERSION:[$file_id] $string");
  }
  if ($log_details ne "syslog") {
    warn "$V_HEADER-$VERSION:[$file_id] $string\n";
  }
  #$nowtime = sprintf "%02d/%02d/%02d %02d:%02d:%02d", $mday, $mon+1, $year+1900, $hour, $min, $sec;
  &debug("error_condition: $V_HEADER-$VERSION: $string",1);
  &cleanup;
  &close_log;
  exit $errcode;
}

sub debug {
  my ($string,$loglevel)=@_;
  return if ( $DEBUG < $loglevel );
  my $dnowtime = strftime("%a, %d %b %Y %H:%M:%S %Z", localtime(time));
  print LOG "$dnowtime:$nprocess: ",$string,"\n";
}

sub working_copy {
  my ($hdr,$last_hdr,$value,$num_of_headers,$last_header,$last_value,$attachment_filename);
  select(STDIN); $|=1;
  
  &debug("w_c: mkdir $ENV{'TMPDIR'}",5);
  mkdir("$ENV{'TMPDIR'}",0750)||&error_condition("$ENV{'TMPDIR'} access denied/file exists - try again later...");
  chdir("$ENV{'TMPDIR'}")||&error_condition("cannot chdir to $ENV{'TMPDIR'}/");

  if (! -d "$scandir/$wmaildir") { mkdir("$scandir/$wmaildir",0750) || &error_condition("cannot create $scandir/$wmaildir - $!"); }
  if (! -d "$scandir/$wmaildir/new") { mkdir("$scandir/$wmaildir/new",0750) || &error_condition("cannot create $scandir/$wmaildir/new - $!"); }
  if (! -d "$scandir/$wmaildir/cur") { mkdir("$scandir/$wmaildir/cur",0750) || &error_condition("cannot create $scandir/$wmaildir/cur - $!"); }
  if (! -d "$scandir/$wmaildir/tmp") { mkdir("$scandir/$wmaildir/tmp",0750) || &error_condition("cannot create $scandir/$wmaildir/tmp - $!"); }

  if (-f "$scandir/$wmaildir/tmp/$file_id" || -f "$scandir/$wmaildir/new/$file_id") {
    &error_condition("$file_id exists, try again later");
  }
  &debug("w_c: start dumping incoming msg into $scandir/$wmaildir/tmp/$file_id [" . &deltatime . "]",5);
  open(TMPFILE,">$scandir/$wmaildir/tmp/$file_id")||&error_condition("cannot write to $scandir/$wmaildir/tmp/$file_id - $!");
  
  my $still_headers=1;
  my $begin_content='';
  my $still_attachment='';
  my $first_received=0;
  while (<STDIN>) {
    if ($still_headers) {
      $HEADERS .= $_;
      #Catch any naughty illegal header chars here
      if ($BAD_MIME_CHECKS && !$IGNORE_EOL_CHECK && /\r|\0/) {
	$illegal_mime=1;
        &debug("w_c: found CRL/NULL in header - invalid if this is a MIME message",2);
      }
      #Put headers into array
      if (/^\s+(.*)$/ && $last_hdr) {
	#Hmmm, a continuation...
	$headers{$last_hdr} .= " $1" if (!$illegal_mime);
      } elsif (/^([^\s]+)/) {
	#This means it's not a continuation header
	if (!$quarantine_event && $BAD_MIME_CHECKS && ($headers{'mime-version'} ne "") && !/^([^\s]+):(.*)$/) {
	  #Wow - a header (not header+value) that goes onto another line - not likely!
	  $illegal_mime=1;
	  $destring='problem';
	  $quarantine_description="Disallowed breakage found in header name - not valid email";
	  $quarantine_event="Policy:Bad_MIME_Break";
	  $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message";
	  &debug("w_c: disallowed breakage found in header name ($_) - not valid email",1);
	  #next;
	} else {
	  /^([^\s]+):(.*)$/;
	  $hdr=$1;
	  $last_hdr=tolower($hdr);
	  $value=$2;
	  $value =~ s/^\s//;
	  if (!$quarantine_event && $BAD_MIME_CHECKS && $headers{'mime-version'} ne "" && $hdr =~ /^[^X].*\(/i) {
	    #Wow - a comment *inside* a standard header name. Only viruses are known to do that
	    #Should we test for [^0-9a-z\_\-\=\+] instead?
	    $illegal_mime=1;
	    $destring='problem';
	    $quarantine_description='Disallowed MIME comment found in header name - not valid email';
	    $quarantine_event="Policy:Bad_MIME_Comment";
	    $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message";
	    &debug("w_c: $quarantine_description",1);
	  }
	  $num_of_headers++;
	}
	#Don't let this array grow without bounds...
	if ($num_of_headers < $MAX_NUM_HDRS) {
	  if ($hdr =~ /^to|cc/i && $headers{tolower($hdr)}) {
	    #Special-case the To: and Cc: headers.
	    #Broken mailers generate messages with multiple 
	    #instances of these, so merge them into one...
	    $headers{tolower($hdr)} .= ",$value";
	  } elsif ($hdr =~ /^(from|x-mail|User-Agent|Organi|Received|Message-ID|Subject)/i && $headers{tolower($hdr)}) {
	    #Make sure any multiples of these headers are remembered, so that 
	    #perlscanner checks can see all instances - just wrap em up
	    #into one long line
	    $headers{tolower($hdr)} .= " $value";
	  } elsif ($hdr =~ /^received$/i && !$first_received) {
	    $first_received=1;
	    $value=~/\[([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)\]\)$/;
	    if ($1 =~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/ && !$ENV{'TCPREMOTEIP'}) {
	      $ENV{'TCPREMOTEIP'}=$1;
	      &debug("w_c: TCPREMOTEIP not set - configuring as $ENV{'TCPREMOTEIP'}",5);
	    }else{
	      #&debug("w_c: no need to reset TCPREMOTEIP from $value,5");
	    }
	  } elsif (!$quarantine_event && $BAD_MIME_CHECKS > 1 && (($headers{'mime-version'} ne "" && tolower($hdr) eq "mime-version") || ($headers{'content-type'} ne "" && tolower($hdr) eq "content-type") || ($headers{'content-transfer-encoding'} ne "" && tolower($hdr) eq "content-transfer-encoding") || ($headers{'content-disposition'} ne "" && tolower($hdr) eq "content-disposition"))) {
	    #Why would a legit message have important MIME headers defined >1 time? It could imply someone is trying to sneak
	    #something past SMTP scanners...
	    #Too much parsing needs to be done to do this correctly - stuff 'em - break the sucker ;-/
	    &debug("w_c: Duplicate MIME headers found [$hdr] - renaming",5);
	    print TMPFILE "$V_HEADER-$VERSION: renamed duplicate MIME headers\n";
	    $_="$V_HEADER-Renamed-$_";
	  } else {
	    #All other headers: the last occurance wins!
	    $headers{tolower($hdr)}=$value;
	  }
	}
      }
      if (/^(\r|\r\n|\n)$/) {
	#headers have finished
	$still_headers=0;
	#Normalize selected headers
	$rawsubject=$headers{'subject'};
	$headers{'subject'}=&normalize_string("Subject:",$headers{'subject'});
	#Try to workaround those nasty broken viruses that produce Content-Type without MIME-Version
	#to get around virus scanners
	if ($headers{'mime-version'} eq "") {
	  #Make sure it's a MIME-style Content-type, Sun used to use Content-type for other purposes...
	  if ($BAD_MIME_CHECKS && $headers{'content-type'} =~ /\//) {
	    print TMPFILE "$V_HEADER-$VERSION: added fake MIME-Version header\nMIME-Version: 1.0\n";
	    $headers{'mime-version'}="1.0";
	    &debug("w_c: added fake MIME-Version header",5);
	  }
	} elsif ($BAD_MIME_CHECKS  && $headers{'content-type'} eq "") {
	  #OK, now do the same for Content-Type. RFCs state "if no Content-Type present, then it's text/plain"
	  #However, Outlook chooses to read the entire message and "figures out" it's mixed/multipart, etc. 
	  #This'll break that - as it should.
	  #I wonder if I shouldn't just block these instead, the only ones I've seen are either viruses or spam...
	  print TMPFILE "$V_HEADER-$VERSION: added fake Content-Type header\nContent-Type: text/plain\n";
	  $headers{'content-type'}="text/plain";
	  &debug("w_c: added fake Content-Type header",5);
	}
	  if ( $headers{'mime-version'} ne "" && $headers{'content-type'} =~ /^(\s+|)([^\/\s\(]+)(\s+|)\/(\s+|)([^\/\s\(\;]+)/ ) {
	    $content_type{$attachment_counter}="$2/$5";
	    &debug("w_c: primary Content-Type of $content_type{$attachment_counter} found",4);
	    if ($log_crypto) {
	      $DOMKEYS="CR:DomKeys(signed)" if ($headers{'domainkey-signature'} ne "");
	      if ($content_type{$attachment_counter} =~ /multipart\/signed/i) {
		$CRYPTO_TYPE="CR:SMIME(signed)" if ($CRYPTO_TYPE eq "" && $headers{'content-type'} =~ /protocol=\"application\/(x\-|)pkcs/i);
		$CRYPTO_TYPE="CR:PGP(signed)" if ($CRYPTO_TYPE eq "" && $headers{'content-type'} =~ /protocol=\"application\/(x\-|)pgp/i);
		&debug("found MIME-based crypto ($CRYPTO_TYPE)",5);
	      } elsif ($content_type{$attachment_counter} =~ /multipart\/encrypted/i) {
		$CRYPTO_TYPE="CR:PGP(encrypted)" if ($headers{'content-type'} =~ /protocol=\"application\/(x\-|)pgp/i);
		&debug("found MIME-based crypto ($CRYPTO_TYPE)",5);
	      }elsif ($content_type{$attachment_counter} =~ /application\/(x\-|)pkcs7/i) {
		$CRYPTO_TYPE="CR:SMIME(encrypted)" if ($headers{'content-type'} =~ /application\/(x\-|)pkcs7/i);
		&debug("found MIME-based crypto ($CRYPTO_TYPE)",5);
	      }
	    }
	  } elsif ($headers{'mime-version'} ne "" && ($BAD_MIME_CHECKS >= 1)) {
	    $destring="problem";
	    $illegal_mime=1;
	    $quarantine_description="Disallowed MIME Content-Type found - not valid email";
	    &debug("w_c: $quarantine_description",1);
	    $quarantine_event="Policy:Bad_MIME_Type";
	    $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message";
	  }
	#}
	#if ( $headers{'content-type'} =~ /boundary(\s*)=(|\s+|\s*\")([^\"\;]+)($|\;|\")/i) {
	if ( $headers{'mime-version'} ne "" && $headers{'content-type'} =~ /boundary(\s*)=(|\s+|\s*\")([^\s\"\;]+)($|\;|\")/i) {
	  $BOUNDARY{$attachment_counter}=$3;
	  #if (!$quarantine_event && $BAD_MIME_CHECKS > 1 && ($BOUNDARY{$attachment_counter} =~ /\"|\;/ || $BOUNDARY{$attachment_counter} eq "")) {
	    #&debug("w_c: RFC2046 says boundaries ($BOUNDARY{$attachment_counter}) can't contain such chars [see bcharsnospace]",4);
	    #$destring="problem";
	    #$illegal_mime=1;
	    #$quarantine_description="Disallowed MIME boundary found - potential virus";
	    #$quarantine_event="Policy:Bad_MIME_Boundary";
	    #$description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message";
	  #}
	  if (!$quarantine_event && $headers{'mime-version'} ne "" && $BAD_MIME_CHECKS > 1 && ( length($BOUNDARY{$attachment_counter}) == 0 || length($BOUNDARY{$attachment_counter}) > 250)) {
	    #RFC2046 says boundarys are 1-70 chars - making it 250 is being *real* liberal...
	    $destring="problem";
	    $illegal_mime=1;
	    $quarantine_description="Disallowed MIME boundary length found (".length($BOUNDARY{$attachment_counter}).") - not valid email";
	    &debug("w_c: $quarantine_description",1);
	    $quarantine_event="Policy:Bad_MIME_Length";
	    $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message";
	  }
	  #Strip off stuff after semicolon, and escape any odd chars
	  $BOUNDARY{$attachment_counter} =~ s/(\"|\;).*$//g;
	  #$BOUNDARY{$attachment_counter} =~ s/([^a-z0-9=\_])/\\\1/gi;
	  $BOUNDARY{$attachment_counter} =~ s/(\W)/\\$1/g;
	  $BOUNDARY_REGEX=$BOUNDARY{$attachment_counter};
	  &debug("w_c: found a top-level boundary definition of $BOUNDARY{$attachment_counter}",4);
	}
	if ( $headers{'content-type'} =~ /name(|\s+)=(|\s+|\s*\")([^\s\"].*)/i) {
	  $ATTACHMENT=$3;
	  $attachment_counter++;
	  #Strip off stuff after semicolon
	  $ATTACHMENT =~ s/(\"|\;).*$//g;
	  &debug("w_c: found a top-level file attachment definition of $ATTACHMENT",4);
	  push(@attachment_list, $ATTACHMENT);
	}
	$headers{$qsmsgid}="<".time . __LINE__ . $$ . "\@$hostname>";
	if ($headers{'message-id'} eq "") {
	  $headers{'message-id'}=$headers{$qsmsgid};
	  print TMPFILE "Message-ID: ",$headers{'message-id'},"\n";
	  $generateMsgID=1;
	} else {
	    #Overwrite with real Message-ID: header
	    $headers{$qsmsgid}=$headers{'message-id'};
	}
      }
    }
    if (/^(\r|\r\n|\n)$/) {
      #&debug("w_c: attachment num=$attachment_counter",4);
      #&debug("w_c: last attachment header: $attachment_header:$attachment_value",4);
      $attach_hdrs{tolower($attachment_header)}=$attachment_value;
      if ($still_attachment ne "") {
	$still_attachment='';
	$begin_content=$attach_hdrs{'content-transfer-encoding'};
      } else {
	$begin_content='';
      }
      $attachment_header=$attachment_value='';
      #Let's see what the last MIME attachment contained
      if ($cd_attachment_filename ne "" && $ct_attachment_filename ne "" && $ct_attachment_filename ne $cd_attachment_filename) {
	if (!$quarantine_event && $BAD_MIME_CHECKS > 1) {
	  &debug("w_c: Disallowed MIME filename manipulation - potential virus",2);
	  $illegal_mime=1;
	  $destring="problem";
	  $quarantine_description='Disallowed MIME filename manipulation - not valid email';
	  &debug("w_c: $quarantine_description",1);
	  $quarantine_event="Policy:Bad_MIME_Manipulation";
	  $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message attachment: \"$ct_attachment_filename\" != \"$cd_attachment_filename\"";
	}
      }
      #$ct_attachment_filename=$cd_attachment_filename='';
      if ($attach_hdrs{'content-type'} =~ /name(|\s+)=(|\s+|\s*\")([^\s\"].*)/i && $ATTACHMENT eq "") {
	$ATTACHMENT=$3;
	#Strip off stuff after semicolon
	$ATTACHMENT =~ s/(\"|\;).*$//g;
	$ATTACHMENT=&normalize_string("Filename:",$ATTACHMENT);
	$ATTACHMENT=tolower($ATTACHMENT);
	if (!grep(/^\Q$ATTACHMENT\E$/,@attachment_list)) {
	  &debug("w_c: found C-T attachment filename '$ATTACHMENT'",4);
	  push(@attachment_list, $ATTACHMENT);
	}
	$ct_attachment_filename=$ATTACHMENT;
	$ATTACHMENT='';
	#&debug("w_c: found a Content-Type attachment filename of '$ct_attachment_filename'",4);
      }
      if ($attach_hdrs{'content-disposition'} =~ /name(|\s+)=(|\s+|\s*\")([^\s\"].*)/i && $ATTACHMENT eq "") {
	$ATTACHMENT=$3;
	#Strip off stuff after semicolon
	$ATTACHMENT =~ s/(\"|\;).*$//g;
	$ATTACHMENT=&normalize_string("Filename:",$ATTACHMENT);
	$ATTACHMENT=tolower($ATTACHMENT);
	if (!grep(/^\Q$ATTACHMENT\E$/,@attachment_list)) {
	  push(@attachment_list, $ATTACHMENT);
	  &debug("w_c: found C-D attachment filename '$ATTACHMENT'",4);
	}
	$cd_attachment_filename=$ATTACHMENT;
	$ATTACHMENT='';
	#&debug("w_c: found a Content-Disposition attachment filename of '$cd_attachment_filename'",4);
      }
      if ($attach_hdrs{'content-type'} =~ /boundary(|\s+)=(|\s+|\s*\")([^\s\"].*)/i) {
	$BOUNDARY{$attachment_counter}=$3;
	#Strip off delimiters around boundary
	$BOUNDARY{$attachment_counter} =~ s/(\"|\;).*$//g;
	$BOUNDARY{$attachment_counter} =~ s/(\W)/\\$1/g;
	if (!$quarantine_event && $headers{'mime-version'} ne "" && $BAD_MIME_CHECKS > 1 && length($BOUNDARY{$attachment_counter}) > 250) {
	  #RFC2046 says boundarys are 0-70 chars
	  $destring="problem";
	  $illegal_mime=1;
	  $quarantine_description="Disallowed MIME boundary length found (".length($BOUNDARY{$attachment_counter}).") - not valid email";
	  &debug("w_c: $quarantine_description",1);
	  $quarantine_event="Policy:Bad_MIME_Boundary";
	  $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message";
	}
	if ( !$quarantine_event && $headers{'mime-version'} ne "" && $BAD_MIME_CHECKS > 1 && $BOUNDARY{$attachment_counter} =~ /^($BOUNDARY_REGEX)$/i) {
	  &debug("w_c: hmm, a new boundary defintion that has already being set. Sounds like a trojan",3);
	  &debug("w_c: broken attachment MIME details - block it!",2);
          $illegal_mime=1;
	  $destring="problem";
          $quarantine_description='Disallowed MIME boundary found in attachment - not valid email';
	  &debug("w_c: $quarantine_description",1);
	  $quarantine_event="Policy:Bad_MIME_Boundary";
	  $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message";
	}
	if ($BOUNDARY_REGEX ne "") {
	  $BOUNDARY_REGEX.="|".$BOUNDARY{$attachment_counter};
	} else {
	  $BOUNDARY_REGEX=$BOUNDARY{$attachment_counter};
	}
	#&debug("w_c: BOUNDARY_REGEX=$BOUNDARY_REGEX",4);
      }
      if ($attach_hdrs{'content-type'} =~ /\//) {
	$attachment_filename='';
	$attachment_filename=$cd_attachment_filename ne "" ? $cd_attachment_filename : $ct_attachment_filename;
	#&debug("w_c: just parsed attachment $attach_hdrs{'content-type'}: filename=$attachment_filename",4);
	if ( $attach_hdrs{'content-type'} =~ /^(\s+|)([^\/\s\(]+)(\s+|)\/(\s+|)([^\/\s\(\;]+)/ ) {
	  $content_type{$attachment_counter}="$2/$5";
	  &debug("w_c: attachment  $attachment_counter: Content-Type of $content_type{$attachment_counter} found",4);
	  if ($attachment_filename =~ /\.(scr|pif|vbs|exe)$/i && $content_type{$attachment_counter} !~ /^(message|text|application|binary)/i) {
	    $quarantine_description="Disallowed file ($attachment_filename) assosiated with unrelated MIME type ($content_type{$attachment_counter}) - forged attachments blocked";
	    $illegal_mime=1;
	    $destring='problem';
	    &debug("w_c: $quarantine_description",1);
	    $quarantine_event="Policy:Forged_Attachment";
	    $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in attachment $attachment_filename";
	  }
	}
	$attach_hdrs{'content-type'}=$attach_hdrs{'content-disposition'}='';
	$ct_attachment_filename=$cd_attachment_filename='';
      }
    } else {
      #&debug("w_c: line=$_",5);
    }
    
    if ($still_attachment ne "") {
      #&debug("w_c: check those attachment headers ($_)",4);
      if (/^([^\s]+):(|\s+)(.*)$/) {
	$last_header=$attachment_header;
	$last_value=$attachment_value;
	$attachment_header=$1;
	$attachment_value=$3;
	$attachment_value =~ s/^\s+//;
	if ($last_header) {
	  #&debug("w_c: $last_header:$last_value",5);
	  $attach_hdrs{tolower($last_header)}=$last_value;
	}
	#&debug("w_c: beginning of $attachment_header, value=$attachment_value",4);
      } elsif (/^\s(.+)/) {
	#&debug("w_c: line :$_: reached",5);
	$attachment_value.=$1;
      } elsif (/^(\r|\r\n|\n|\s+)$/) {
	#Yeah - I should block spaces, but too many valid lists send out such junk...
	$still_attachment='';
      } else {
	#This will catch headers that are *correctly* broken over two lines.
	#No known mailer does that, but virus writers do, so we block it.
	#Note that a lot of mailing-lists (and AV systems...) shove their trailers
	#on the bottom of messages irrespective of whether they are MIME or not - so
	#we must allow such "hacks" to slip through
	if (!$quarantine_event && $BAD_MIME_CHECKS > 1 && ($BOUNDARY_REGEX ne "" && $still_attachment !~ /^\-\-($BOUNDARY_REGEX)\-\-$/) ) {
	  &debug("w_c: broken attachment MIME details (still_attachment=$still_attachment, but BOUNDARY_REGEX=\"$BOUNDARY_REGEX\")- block it!",2);
	  $illegal_mime=1;
	  $destring="problem";
	  $quarantine_description='Disallowed content found in MIME attachment - not valid email';
	  &debug("w_c: $quarantine_description",1);
	  $quarantine_event="Policy:Bad_MIME_Header";
	  $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message";
	}
      }
    }
    if ($begin_content =~ /base64/i && !/^\s/) {
      #&debug("w_c: begin='$begin_content',line=$_",5);
      $begin_content='';
      #Only looking for base64 encoded as both QP and binary appear to arrive corrupted under Outlook
      if ($_ =~ /^TV(qq|qQ|r1|pQ|pA|py|rm|rh|oF|oI|rQ|o8|ou|oA)/) {
	&debug("w_c: base64 looks like a Windows executable, filename=$attachment_filename,type=$content_type{$attachment_counter}",4);
	if (!$quarantine_event && $BAD_MIME_CHECKS > 1 && $content_type{$attachment_counter} !~ /^(binary|application)/i) {
	  #As far as I'm aware, a Windows/DOS executable should always be of type "application/<something>"
	  $illegal_mime=1;
	  $destring="problem";
	  $quarantine_description="Disallowed executable attachment associated with \"$content_type{$attachment_counter}\" MIME type - forged attachment";
	  $quarantine_event="Policy:Forged_Attachment";
	  $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in attachment \"$attachment_filename\"";
	  &debug("w_c: $quarantine_description",1);
	}
      }
      if ($_ =~ /^(UEsDB[AB]|UEswMFBL)/) {
	&debug("w_c: base64 looks like a zip file, filename=$attachment_filename,type=$content_type{$attachment_counter}",4);
	if (!$quarantine_event && $BAD_MIME_CHECKS > 2 && $attachment_filename !~ /\.zip$/i) {
	  #This is a zip file, and yet the filename doesn't end in .zip - should quarantine it!
	  $illegal_mime=1;
	  $destring="problem";
	  $quarantine_description="Disallowed zip attachment when not associated with a .zip filename - forged attachment";
	  $quarantine_event="Policy:Forged_Attachment";
	  $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in attachment \"$attachment_filename\"";
	  &debug("w_c: $quarantine_description",1);
	}
      }
    }
    if ($BOUNDARY_REGEX ne "" && /^\-\-($BOUNDARY_REGEX)/) {
      $still_attachment=$_;
      chomp($still_attachment);
      if (/^\-\-($BOUNDARY_REGEX)\-\-.$/) {
	&debug("w_c: found end of attachment boundary, BOUNDARY_REGEX was '$BOUNDARY_REGEX'...",4);
	my ($delete_bb)=$1;
	$delete_bb =~ s/(\W)/\\$1/g;
	$BOUNDARY_REGEX =~ s/\Q$delete_bb\E//;
	$BOUNDARY_REGEX =~ s/\|\|//;
	$BOUNDARY_REGEX =~ s/(^\||\|$)//;
	&debug("w_c: now that '$delete_bb' has been removed, it's '$BOUNDARY_REGEX'...",5);
      }
      $attachment_counter++;
      #&debug("w_c: found :$BOUNDARY_REGEX: - must be attachment section $attachment_counter",4);
    }
    if ($CRYPTO_TYPE eq "" && $log_crypto) {
      
      $CRYPTO_TYPE="CR:PGP(old-signed)" if (/^(\-\-\-\-\-BEGIN PGP SIGNATURE\-\-\-\-\-|LS0tLS1CRUdJTiBQR1AgU0lHTkFUVVJFLS0tLS0)/);
      $CRYPTO_TYPE="CR:PGP(old-encrypted)" if (/^(\-\-\-\-\-BEGIN PGP MESSAGE\-\-\-\-\-|LS0tLS1CRUdJTiBQR1AgTUVTU0FHRS0tLS0t)/);
      &debug("w_c: found old PGP crypto ($CRYPTO_TYPE)",2) if ($CRYPTO_TYPE ne "");
    }
    &check_and_grab_attachments;
    print TMPFILE ;
  }
  close(TMPFILE)||&error_condition("cannot close $scandir/$wmaildir/tmp/$file_id - $!");

  #scanning message has finished

  $HEADERS =~ s/\r|\0//g;

  &debug("w_c: rename new msg from $scandir/$wmaildir/tmp/$file_id to $scandir/$wmaildir/new/$file_id",5);
  &debug("w_c: Total time between DATA command and '.' was " . &deltatime . " secs",2);
  &debug("w_c: this is basically the time it took the client to send the message over the network",5);
  &debug("w_c: resetting timer so as to measure actual VF-Scanner processing time",5);
  $start_time=[gettimeofday];
  #Not atomic but who cares about the overhead - this is the only app using this area...
  link("$scandir/$wmaildir/tmp/$file_id","$scandir/$wmaildir/new/$file_id")||&error_condition("cannot link $scandir/$wmaildir/tmp/$file_id into $scandir/$wmaildir/new/$file_id - $!");
  unlink("$scandir/$wmaildir/tmp/$file_id")||&error_condition("cannot delete $scandir/$wmaildir/tmp/$file_id - $!");
  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$atime,$mtime,$ctime,$blksize,$blocks);
  ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$msg_size,$atime,$mtime,$ctime,$blksize,$blocks) = stat("$scandir/$wmaildir/new/$file_id");
  if (!$headers{'date'}) {
    my (@day, @mon);
    $day[0]='Sun';$day[1]='Mon';$day[2]='Tue';$day[3]='Wed';$day[4]='Thu';$day[5]='Fri';$day[6]='Sat';
    $mon[0]='Jan';$mon[1]='Feb';$mon[2]='Mar';$mon[3]='Apr';$mon[4]='May';$mon[5]='Jun';$mon[6]='Jul';$mon[7]='Aug';$mon[8]='Sep';$mon[9]='Oct';$mon[10]='Nov';$mon[11]='Dec';
    my ($tm_sec,$tm_min,$tm_hour,$tm_mday,$tm_mon,$tm_year,$tm_wday,$tm_yday,$tm_isdst);
    ($tm_sec,$tm_min,$tm_hour,$tm_mday,$tm_mon,$tm_year,$tm_wday,$tm_yday,$tm_isdst)=localtime;
    $tm_year += 1900;
    $headers{'date'}=$day[$tm_wday].", $tm_mday ".$mon[$tm_mon]." $tm_year $tm_hour:$tm_min:$tm_sec";
  }
}

sub grab_envelope_hdrs {
  select(STDOUT); $|=1;
  
  open(SOUT,"<&1")||&error_condition("cannot dup fd 0 - $!");
  while (<SOUT>) {
    ($env_returnpath,$env_recips) = split(/\0/,$_,2);
    if ( ($returnpath=$env_returnpath) =~ s/^F(.*)$// ) {
      $returnpath=$1;
      ($recips=$env_recips) =~ s/^T//;
      $recips =~ /^(.*)\0+$/;
      $recips=$1;
      $recips =~ s/\0+$//g;
      #Keep a note of the NULL-separated addresses
      $trecips=$recips;
      $one_recip=$trecips if ($trecips !~ /\0T/);
      $recips =~ s/\0T/\,/g;
    }
    #only meant to be one line!
    last;
  }
  close(SOUT)||&error_condition("cannot close fd 1 - $!");
  if ( ($env_returnpath eq "" && $env_recips eq "") || ($returnpath eq "" && $recips eq "") ) {
    #At the very least this is supposed to be $env_returnpath='F' - so
    #qmail-smtpd must be officially dropping the incoming message for
    #some (valid) reason (including the other end dropping the connection).
    &debug("g_e_h: no sender and no recips. Probably due to SMTP client dropping connection. Nothing we can do - cleanup and exit. This is not necessarily an error!",5);
    &debug("g_e_h: no sender and no recips, from $smtp_sender. Dropping, this isn't a QS error.",1);
    if ($DEBUG > 2) {
       warn "$$ QS-$VERSION: no sender and no recips, from $smtp_sender\n" ;
    } else {
       warn "$V_HEADER-$VERSION: no sender and no recips, from $smtp_sender\n";
    }
    &cleanup;
    &close_log;
    exit;
  }
  &debug("g_e_h: return-path='$returnpath', recips='$recips'",1);
}


sub deconstruct_msg {
  my ($start_decon_time) = [gettimeofday];
  my $save_filename ='';
  my ($new_filename,$MAYBETNEF,$tnef_status);

  my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat("$scandir/$wmaildir/new/$file_id");

  #override absurd values
  $MAX_SCAN_SIZE=10000000 if ($MAX_SCAN_SIZE < 10000000);
  if ($size > $MAX_SCAN_SIZE)  {
    &debug("d_m: msg is $size bytes - too large to scan",1);
    $SKIP_SCANNING=1;
  }
  &debug("d_m: starting $mimeunpacker_binary <$scandir/$wmaildir/new/$file_id [" . &deltatime . "]",5);
  open(MIME,"$mimeunpacker_binary  <$scandir/$wmaildir/new/$file_id 2>&1|")||&error_condition("cannot call $mimeunpacker_binary - $!");
  while (<MIME>) {
    next if (/exists/);
    &error_condition("d_m: output spotted from $mimeunpacker_binary ($_) - that shouldn't happen!");
  }
  close(MIME)||&error_condition("cannot close $mimeunpacker_binary - $!");
  my $unpacker='';
  
  opendir(DIR,"$ENV{'TMPDIR'}/")||&error_condition("cannot open dir $ENV{'TMPDIR'}/ - $!"); 
  my @all_unpacked_files = grep(!/^\.+$/, readdir(DIR));
  closedir(DIR);
  &debug("d_m: finished $mimeunpacker_binary [" . &deltatime . "]",5);
  #If you have the tnef app, you'll be able to scan broken M$ attachments
  
  if ( $tnef_binary ) {
    &debug("d_m: Checking all attachments to see if they're MS-TNEF",5);
    foreach $save_filename (@all_unpacked_files) {
      #Clean up $save_filename so as to keep taint happy
      $save_filename =~ /^(.*)$/; $save_filename=$1;
      ($new_filename=$save_filename) =~ s/([^a-z0-9\.\-\_\+\=\~]+)//gi;
      if ($save_filename ne $new_filename) {
	$new_filename =~ /(\.[^\.]+)$/;
	$new_filename=&uniq_id."$new_filename";
	rename($save_filename,$new_filename);
	&debug("d_m: ren $save_filename to $new_filename",5);
	$save_filename=$new_filename;
      }
      #Who cares if it is or isn't tnef, just scan it!
      if ($tnef_binary) {
	$MAYBETNEF=`$tnef_binary --number-backups -d $ENV{'TMPDIR'}/ -f $ENV{'TMPDIR'}/$save_filename 2>&1`;
	$tnef_status=$?;
	&debug("d_m: is $ENV{'TMPDIR'}/$save_filename is a TNEF file?: $tnef_status [" . &deltatime . "]",5);
      }
    }
  }

  &debug("d_m: Check for zip files...",5);
  #Re-initialize directory listing
  opendir(DIR,"$ENV{'TMPDIR'}/")||&error_condition("cannot open dir $ENV{'TMPDIR'}/ - $!"); 
  @all_unpacked_files = grep(!/^\.+$/, readdir(DIR));
  closedir(DIR);
  foreach $save_filename (@all_unpacked_files) {
    #Clean up $save_filename so as to keep taint happy
    $save_filename =~ /^(.*)$/; $save_filename=$1;
    ($new_filename=$save_filename) =~ s/([^a-z0-9\.\-\_\+\=\~]+)//gi;
    if ($save_filename ne $new_filename) {
      $new_filename =~ /(\.[^\.]+)$/;
      $new_filename=&uniq_id."$new_filename";
      rename($save_filename,$new_filename);
      &debug("d_m: ren $save_filename to $new_filename",5);
      $save_filename=$new_filename;
    }
    if ( $save_filename =~ /\.(zip|exe)$/i) {
      &unzip_file($save_filename);
    }
  }

  if (!$redundant_scanning) {
    if (-f "$ENV{'TMPDIR'}/$save_filename") {
      system $rm_binary,"-f","$ENV{'TMPDIR'}/$save_filename";
    }
  }

  my($decon_time)=tv_interval ($start_decon_time, [gettimeofday]);
  &debug("d_m: unpacking message took $decon_time seconds",5);
}

sub init_scanners {
  my($start_init_scanners_time)=[gettimeofday];
  &debug("ini_sc: start scanning",5);
  chdir("$ENV{'TMPDIR'}/");
  
  #Delete original zip'ped attachment as there's no point 
  #in the other scanners double-scanning it - unless $redundant scanning
  #is set....
  if ($redundant_scanning) {
    link("$scandir/$wmaildir/new/$file_id","$ENV{'TMPDIR'}/orig-$file_id");
  }
  &debug("ini_sc: recursively scan the directory $ENV{'TMPDIR'}/",5);

  #Run AV scanners - even if the message is already going to be quarantined
  #due to some Policy: this way you get the definitive answer as to what is
  #a virus... The exception to this is if it looks like a DoS attack - then
  #don't run the AVs over it - as they may be the ones affected by the DoS...

  # st: JLH has changed this part... let see if I can mantain mine compatible with him.
  &scanloop if (!$quarantine_DOS && !$SKIP_SCANNING);

  chdir("$scandir");

  my($decon_time)=tv_interval ($start_init_scanners_time, [gettimeofday]);
  &debug("ini_sc: finished scan of '$ENV{'TMPDIR'}'...",5);
  &debug("ini_sc: scanning message took $decon_time seconds",3);
}


sub perlscan_scanner {
  #This is most efficient if called from within deconstruct_msg

  my($start_perlscan_time)=[gettimeofday];
  my (%array,$var,$lfile,$filename,$section,$apptype,$save_filename);
  my ($type,$desc,$file,$filepattern,$filepath);
  my ($normalized_hdr,$ps_skipfile,$extension);
  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks,$fsize);
  my ($attachment_list,$perlscan_time);
  &debug("p_s: starting scan of directory '$ENV{'TMPDIR'}'...",5);
  &debug("p_s: spddns extension blocking list: $spddns_ext",1) if $spddns_ext;

  # use DB_File;
  
  
  tie (%array, 'DB_File', "$db_filename.db", O_RDONLY, 0600) || &error_condition("cannot read $db_filename.db - $!");

  if (!$quarantine_event && $illegal_mime && $headers{'mime-version'} && $BAD_MIME_CHECKS) {
    $destring="problem";
    $quarantine_description="Disallowed  characters found in MIME headers" if (!$quarantine_description);
    $quarantine_event="Policy:Bad_MIME";
    $description .= "\n---perlscanner results ---\n$destring '$quarantine_description'\n found in message";
    &debug("p_s: something to block! ($quarantine_description)",1);
  }
  #check out headers against DB...
  
  foreach $var (sort keys(%array)) {
    ($type,$desc)=split(/\t/,$array{$var},2);
    &debug("p_s:  '$var' = '$type' = '$desc'",5);
    if ($type !~ /^SIZE=(\-|\<|\>|)[0-9]+$/) {
      &debug("p_s:  type is a header!",5);
      $type =~ s/^Policy\-//gi;
      $var=~s/^[0-9]+://;
      if (!grep(/^$type$/,@virtualheaders_array)) {
	#only force lowercase if they are "real" headers
	$type=tolower($type);
      }else{	
	$headers{$type}=$desc if ($headers{$type} eq "");
      }
      $virtualheader{$type}=$var;
      &debug("p_s: checking for objects containing $type: $var",5);
      $normalized_hdr=&normalize_string("$type:",$headers{$type});

      #Check headers against the "virtualheaders" from quarantine-events.txt
      if ($headers{$type} ne "" && ($headers{$type} =~ /^$virtualheader{$type}$/ || $normalized_hdr =~ /^$virtualheader{$type}$/i)) {
	$quarantine_description="$desc";
	($quarantine_event=$quarantine_description) =~ s/\s/_/g;
	$quarantine_event="Perlscan:".substr($quarantine_event,0,$QE_LEN);
	$quarantine_event=~s/_$//g;
	$description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in file $ENV{'TMPDIR'}/$file";
	&debug("p_s: something to block! ($quarantine_description)",1);
	last;
      }
    } else {
      &debug("p_s: type is a size!",5);
    }
  }

  #opendir(DIR,"$ENV{'TMPDIR'}/")||&error_condition("cannot open dir $ENV{'TMPDIR'}/ - $!"); 
  #@allfiles = grep(!/^\.+$/, readdir(DIR));
  #closedir(DIR);
  open(DIR,"$find_binary $ENV{'TMPDIR'}/ -type f |")||&error_condition("cannot open dir $ENV{'TMPDIR'}/ - $!");
  #append any ORIGINAL uuencoded filenames to this directory array
  #so that perlscanner can match on uuencoded filenames
  my @allfiles=<DIR>;
  close(DIR);

  #merge all crypto details
  my ($CRYPTO_DETAILS)="$CRYPTO_TYPE:$DOMKEYS";


  #Block if "Sensitivity:" header set and yet no sign of encryption used
  if ($headers{'sensitivity'} =~ /private|confidential/i) {
    if ($virtualheader{'ISSENSITIVEANDNOCRYPTO'} ne "" && $CRYPTO_TYPE !~ /encrypted/) {
      $quarantine_description=$headers{'ISSENSITIVEANDNOCRYPTO'};
      ($quarantine_event=$quarantine_description) =~ s/\s/_/g;
      $quarantine_event="Policy:Must_Encrypt";
      $quarantine_event=~s/_$//g;
      $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in message";
      &debug("p_s: something to block! ($quarantine_description)",1);
    }
    $CRYPTO_TYPE=~s/\)$/,private\)/;
  }

  if ($virtualheader{'CRYPTODETAILS'} ne "" && !$quarantine_event && $CRYPTO_DETAILS ne "") {
    &debug("check crypto characteristics of this message against $virtualheader{'CRYPTODETAILS'}",5);
    if ($CRYPTO_DETAILS =~ /$virtualheader{'CRYPTODETAILS'}/) {
      $destring='problem';
      $quarantine_description=$headers{'CRYPTODETAILS'};
      $quarantine_event="Policy:No_Crypto";
      $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in file $ENV{'TMPDIR'}/$file";
      &debug("p_s: something to block! ($quarantine_description)",1);
      return;
    }
  }
  if ($#allfiles > $MAX_NUM_UNPACKED_FILES) {
    &debug("w_c: more than $MAX_NUM_UNPACKED_FILES files found - quarantine",2);
    $illegal_mime=1;
    $destring='problem';
    $quarantine_description="Too many file components found (".$#allfiles.") - potential DoS";
    $quarantine_event="Policy:Many_Files";
    $quarantine_DOS=$quarantine_event;
    $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in file $ENV{'TMPDIR'}/$file";
    $file_desc .= "too_many:$msg_size\t" if ($file_desc !~ /\Q$file\E:$size\t/);
    &debug("p_s: something to block! ($quarantine_description)",1);
    return;
  }
  foreach $filepath (@allfiles,@uufile_list,@zipfile_list,@attachment_list) {
    chomp($filepath);
    ($file=$filepath)=~s/^.*\///g;
    #skip files that reformime/ripmime generates.
    #This will potentially allow baddies to smuggle files through
    #by using filenames like this... Nothing can be done about that:-(
    #Reformime generates filenames of the form:
    # 967067231.24320-X.host.name (where X is a number)
    #Ripmime generates filenames of the form:
    # textfileX (where X is a number)
    if ($file =~ /^[0-9]+\.[0-9]+\-[0-9]+\.$hostname|^(orig\-|)$file_id|^textfile[0-9]+/) {
      &debug("p_s: skipping auto-generated file $file",5);
      $ps_skipfile=1;
    } else {
      &debug("p_s: checking $file against perlscanner database...",5);
      $ps_skipfile=0;
    }

    if (!$ps_skipfile && $virtualheader{'FILELENGTHTOOLONG'} ne "" && !$quarantine_event && length($file) > 256 && $BAD_MIME_CHECKS > 1 ) {
      &debug("w_c: majorly long attachment filename found - block it",2);
      $quarantine_description=$headers{'FILELENGTHTOOLONG'};
      $illegal_mime=1;
      $destring='problem';
      $quarantine_event="Policy:Attach_Length";
      $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in file $ENV{'TMPDIR'}/$file";
      $file_desc .= "$file:$msg_size\t" if ($file_desc !~ /\Q$file\E:$size\t/);
      &debug("p_s: something to block! ($quarantine_description)",1);
      return;
    }

    #Do the patently obvious filename security checks here
    if ( !$ps_skipfile && $BAD_MIME_CHECKS > 1) {
      #Not as thorough as I'd like - but I got too many false positives doing it more generically... :-(
      #The VALID_WINDOWS_EXTENSIONS is based on double-barrel virii caught in a years worth of Qmail-Scanner
      #logs (gotta love those logs!). Notice that I expressly allow "file.exe.exe" through - as the double-extension
      #doesn't hide anything [just implies a user made a mistake]
      if ($virtualheader{'FILEDOUBLEBARRELED'} ne "" && !$quarantine_event && ($file =~ /(^.*)\.($VALID_WINDOWS_EXTENSIONS)\s*\.($SNEAKY_WINDOWS_EXTENSIONS)$/i) && $file !~ /(\.[a-z0-9]{3})\1$|\.pp.\.pp.$/i) {
	$quarantine_description=$headers{'FILEDOUBLEBARRELED'};
	$illegal_mime=1;
	$destring='problem';
	$quarantine_event="Policy:Win_Ext";
	$description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in file $ENV{'TMPDIR'}/$file";
	$file_desc .= "$file:$msg_size\t" if ($file_desc !~ /\Q$file\E:$size\t/);
	&debug("p_s: something to block! ($quarantine_description)",1);
	return;
      }
      if ($virtualheader{'FILECLSID'} ne "" && !$quarantine_event && $file =~ /\{[0-9a-f]{8}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{4}\-[0-9a-f]{12}\}$/i) {
	$quarantine_description=$headers{'FILECLSID'};
	$destring='problem';
	$quarantine_event="Policy:Win_CLSID";
	$description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in file $ENV{'TMPDIR'}/$file";
	$file_desc .= "$file:$msg_size\t" if ($file_desc !~ /\Q$file\E:$size\t/);
	&debug("p_s: something to block! ($quarantine_description)",1);
	return;
      }
    }
    if ($file =~ /(^.*)(\.[^\.]+)\.?$/) {
      $extension=tolower($2);
    } else {
      $extension="";
    }
    $lfile = tolower($file);
    &debug("p_s: file $file is lowercased to $lfile and has extension $extension",5) if (!$ps_skipfile);
    #Stat'ing attachment names from @attachment_list will fail on filenames that reformime rewrites
    #that's OK, as they'll still be picked up via their new filename
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat("$filepath");
    #As you stat virtual files as well as real ones, you can't do this check against virtual files...
    if ($effective_uid ne "" && $uid ne "" && $uid != $effective_uid) {
      $DEBUG=101;
      &error_condition("owner of unpacked file \"$filepath\" (uid=$uid) doesn't match UID of VF-Scanner (uid=$effective_uid) - can't expect this to work. Fix whatever is creating files with uid=$uid");
    }
    if ($ino && $file_desc !~ /\Q$file\E:$size\t/) {
      #Sanity check so that the virtual attachments don't get double-counted
      $file_desc .= "$file:$size\t";
    }
    &debug("p_s: compare $lfile (size $size) against perlscanner database",5) if (!$ps_skipfile);

    foreach (split (/,/,$spddns_ext)) {
      if ($extension =~ /^\.($_)$/i) {
        $destring="Disallowed attachment type";
        $fsize="SIZE=-1";
        $quarantine_description=toupper(substr($extension,1)) . " files are not allowed per security policy";
        $attachment_list.="$file:$size,";
	last;
      }
    }
    if (!$quarantine_description) {
      if ($array{$extension} && !$ps_skipfile) {
	$destring="Disallowed attachment type";
	($fsize,$quarantine_description) = split(/\t/,$array{$extension},2);
	$attachment_list.="$file:$size,";
      }else{
        foreach $filepattern (keys %array) {
	  #&debug("p_s: does '$filepattern' match against $lfile?",5);
	  if ( $lfile =~ /^${filepattern}$/i) {
	    #$destring="Disallowed attachment type";
	    ($fsize,$quarantine_description) = split(/\t/,$array{$filepattern},2);
	    $attachment_list.="$file:$size,";
	  }
        }
      }
    }

    $fsize=~s/^SIZE=//;
    if (!$ps_skipfile && $quarantine_description && !$quarantine_event && $size ne "" && ($size eq $fsize || $fsize =~ /^-1$/i || ($fsize =~ /^>([0-9]+)$/ && $size > $1) || ($fsize =~ /^<([0-9]+)$/ && $size < $1) )) {
      ($quarantine_event=$quarantine_description) =~ s/\s/_/g;
      if ($quarantine_event=~/gr[ea]ylist/i) {
	$quarantine_event="Perlscan:Greylisted";
      }else{
	$quarantine_event="Perlscan:".substr($quarantine_event,0,$QE_LEN);
      }
      $quarantine_event=~s/_$//g;
      $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in file $ENV{'TMPDIR'}/$file";
      $section=$apptype=$save_filename=$filename="";
      &debug("p_s: something to block! ($quarantine_description)",1);
      #	return;
    }
  }
  untie %array;


  if ($CRYPTO_TYPE=~/CR:ZIP/ && $virtualheader{'ZIPPASSWORDPROTECTED'} ne "" && !$quarantine_event) {
    $quarantine_description=$headers{'ZIPPASSWORDPROTECTED'};
    $destring='problem';
    $quarantine_event="Policy:Encrypted_ZIP";
    $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in zip file";
    $file_desc .= "encrypted_zip:$msg_size\t";
    &debug("u_f: something to block! ($quarantine_description)",1);
    return;
  }

  # st: cosmetic, if the messages is spam don't call it a virus.
  if ($quarantine_description =~ /spam/i) {
     $destring='problem';
  }

  chdir("$scandir/");
  my($stop_perlscan_time)=[gettimeofday];
  $perlscan_time = tv_interval ($start_perlscan_time, $stop_perlscan_time);
  &debug("p_s:  finished scan of dir $ENV{'TMPDIR'} in $perlscan_time secs",5);
  &debug("p_s: finished scan in $perlscan_time secs",2);
}

sub scanexec {
  my $scanner = shift;
  my $timeout = int ($MAXTIME/scalar(@scanner_array));
  $timeout = 1 unless $timeout;

  my($old_alarm,$old_handler,$remaining_alarm);
  $old_alarm = alarm(0);
  $old_handler = $SIG{'ALRM'};

  if ( $old_alarm && ($timeout > $old_alarm) ) {
    $timeout = $old_alarm;
  }

  eval {
    local $SIG{ALRM} = sub { die "alarm\n" };
    alarm ($timeout);
    &{$scanner} (@_);
    $remaining_alarm = alarm(0);
  };

  my $failflag = 0;
  if ($@) {
    die unless ($@ eq "alarm\n" || $@ eq "connect\n");
    $remaining_alarm = 0;
    $quarantine_event='0';
    $failflag = 1;

    if ($@ eq "alarm\n") {
      &debug("scanexec: timeout of $scanner has expired (timeout = ${timeout} s)",2);
    }
  }

  $SIG{'ALRM'} = $old_handler ? $old_handler : 'DEFAULT';

  if ( $old_alarm ) {
    $old_alarm = $old_alarm - $timeout + $remaining_alarm;
    if ($old_alarm > 0) {
      alarm($old_alarm);
    } else {
      kill ('ALRM',$$);
    }
  }

  if ($failflag && $scanner eq "fpscand_scanner") {
    foreach my $i (@scanners_installed) {
      if ($i eq "fpscan_scanner") {
	&scanexec("fpscan_scanner");
	last;
      }
    }
  }
}

sub scanloop {
  #my($scanType)=@_;
  #&debug("scanloop($scanType): starting scan of directory \"$ENV{'TMPDIR'}\"...",5);
  &debug("scanloop: starting scan of directory \"$ENV{'TMPDIR'}\"...",5);

  my ($scanner);
  #Remember any policy blocks that have already occurred, but reset
  #$quarantine_event so that if a virus is found, that "wins"
  #$quarantine_event_tmp=$quarantine_event;     # st: done above.
  $quarantine_event='0';
  foreach $scanner (@scanner_array) {
    # st: if this recipient has spamassassin in his array we will add the X-Spam headers.
    $sa_rcpt='1' if ( $scanner =~ /spam/ );

    # st: s_p_d, if we have multiples recipients (a lot) run each scanner just once... (except SA)
    if (exists $found_event{$scanner}) {
      ($destring,$quarantine_event,$quarantine_description,$description)=split(/\t/,$found_event{$scanner});
      $scanner =~ s/^(.*)_scanner$/$1/;
      $scanner =~ s/^perlscan$/p_s/;

      # st: spamassassin and multiple recipients...
      if ($scanner =~ /spam/i) {
	 if ($msg_size > $sa_maxsize) {
	    &debug("SA: message too big ($msg_size) - skip it",2);
	    next;
	 }
	 if ($sa_sql) {
	    # st: rerun SA, each user could have his own required_hits...
	    # but we cannot run again verbose_spamassassin, then run sa_alt and add sa_report
	    # It is better forget verbose_spamassassin for ever...
	    if (!$sa_fast) {
	       $sa_alt='1';
	       # $sa_debug='1';
	       $sa_hdr_report='1';
	    }
	    $scanner = "spamassassin_alt" if ($sa_alt);
	    scanexec ($scanner,1);
	    next;
	 } else {
	    &check_sa_score ($sa_hits,0,1) if ($sa_hits && ($sa_hits ne "\?"));
	    if ($sa_hits < $required_hits || ($sa_hits eq "\?")) {
	       &debug("SA: finished scan for $one_recip - hits=$sa_hits/$required_hits",1);
	    }
	 }
         last if $quarantine_description;
         next;
      }

      if ($quarantine_description ne "") {
	 &debug("$scanner: $destring found $quarantine_description",1);
	 last;
      } else {
	 &debug("$scanner: already checked and clear, skip",3);
	 next;
      }
    }

    #Any scanner errors caused by broken zip files/etc will be ignored
    # - not sure how that should be handled...
    &debug("scanloop: scanner=$scanner,plain_text_msg=$plain_text_msg",5);
    
    # st: call spamassassin_alt if sa_alt is enabled
    $scanner = "spamassassin_alt" if ( $scanner =~ /spam/i && $sa_alt );

    # st: I am not sure if this is correct
    if ($scanner =~ /perl/i) {
      $quarantine_event=$quarantine_event_tmp;
    }

    #Just run virus scanners over mail that isn't plain text
    if ($plain_text_msg) {
      #If it's plain text - just run anti-spam checks and perl_scanner
      scanexec ($scanner) if ($scanner =~ /spam|perl/i);
    } else {
      scanexec ($scanner);
    }

    if ($scanner =~ /perl/i) {
      last if ($quarantine_event);
      next;
    }

    $scanner = "spamassassin" if ($scanner eq "spamassassin_alt");
    if ($quarantine_event) {
      #Make sure this is set correctly
      $destring="virus" if ($quarantine_event !~ /spam/i && $scanner !~ /perl/i );
      $found_event{$scanner}="$destring\t$quarantine_event\t$quarantine_description\t$description";
      # st: mark the viruses we don't want to quarantine, but delete them
      if (($virus_to_delete ne "") && ($quarantine_description=~/($virus_to_delete)/i)) {
	$del_message='1';
	&debug("v_t_d: Virus ($quarantine_description), dropping",5);
      }
      #If one scanner finds a virus - why run the rest over it?
      last;
    }
    # st: per user settings... I have to think about...
    $found_event{$scanner}="\t0\t\t";
  }
  &debug("scanloop: finished scan of \"$ENV{'TMPDIR'}\"...",5);
}

sub qmail_requeue {
  my($sender,$env_recips,$msg)=@_;
  my ($temp,$findate);

  &debug("q_r: fork off child into $qmailqueue...",5);
  
  #($recips=$env_recips) =~ s/^T//;
  #$recips =~ s/\0T/\,/g;
  #$recips =~ /^(.*)\0+$/;
  #$recips = $1;
  #$recips =~ s/\0+$//g;
  
  # Create a pipe through which to send the envelope addresses.
  pipe (EOUT, EIN) or &error_condition("Unable to create a pipe. - $!");
  select(EOUT);$|=1;
  select(EIN);$|=1;
  # Fork qmail-queue.  The qmail-queue child will then open fd 0 as
  # $message and fd 1 as the reading end of the envelope pipe and exec
  # qmail-queue.  The parent will read in the addresses and pass them 
  # through the pipe and then check the exit status.

  $elapsed_time = tv_interval ($start_time, [gettimeofday]);
  local $SIG{PIPE} = 'IGNORE';
  my $pid = fork;

  if (not defined $pid) {
    &error_condition ("Unable to fork. (#4.3.0) - $!");
  } elsif ($pid == 0) {
    # In child.  Mutilate our file handles.
    close EIN; 
    
    open(STDIN,"<$msg")|| &error_condition ("Unable to reopen fd 0. (#4.3.0) - $!");

    open (STDOUT, "<&EOUT") ||  &error_condition ("Unable to reopen fd 1. (#4.3.0) - $!");
    select(STDIN);$|=1;
    &debug("q_r: xstatus=$xstatus",5);
    my @my_sa_score = ($tag_sa_score =~ m/(\d\.\d\/\d\.\d)/);
    my @score = split(/\//, $my_sa_score[0]);
    if ($score[0] >= $score[1] && $tag_sa_score ne "SA:0(?/?):") {
	$qmailqueue = $qmailqueue2;
	&debug("QS: Setting alternative qmailqueue $qmailqueue2",2);
    }
    open (QMQ, "|$qmailqueue")|| &error_condition ("Unable to open pipe to $qmailqueue [$xstatus] (#4.3.0) - $!");
    ($sec,$min,$hour,$mday,$mon,$year) = gmtime(time);
    $elapsed_time = tv_interval ($start_time, [gettimeofday]);
    $findate = POSIX::strftime( "%d %b ",$sec,$min,$hour,$mday,$mon,$year);
    $findate .= sprintf "%02d %02d:%02d:%02d -0000", $year+1900, $hour, $min, $sec;
    print QMQ "Received: from $remote_smtp_host$remote_smtp_auth by $hostname (envelope-from <$returnpath>, uid $real_uid) with VF-scanner-$VERSION \n";
    if ($scanner_array[0] ne "none") {
      print QMQ " ($SCANINFO \n Clear:$tag_score$tag_sa_score. \n";
      print QMQ " Processed in $elapsed_time secs); $findate\n";
      if ($sa_comment ne "" && $sa_rcpt) {
        print QMQ "X-Spam-Status: $sa_comment\n";
        print QMQ "X-Spam-Level: $sa_level\n" if ($sa_level ne "");
        print QMQ "X-Spam-Report: SA TESTS\n$sa_report\n" if ($sa_report && $sa_hdr_report);
      }
      #Only add these headers for Internet-incoming
      if ( $descriptive_hdrs && !$QS_RELAYCLIENT) {
        print QMQ "${V_HEADER}-Mail-From: $returnpath via $hostname\n";
        print QMQ "${V_HEADER}-Rcpt-To: $recips\n" if ($descriptive_hdrs eq "2");
        print QMQ "$V_HEADER: $VERSION (Clear:$tag_score$tag_sa_score. Processed in $elapsed_time secs Process $nprocess)\n";
      }
    }
    my $still_headers=1;
    my $seen_env=0;
    while (<STDIN>) {
      if ($still_headers && $sa_fast) {
	#break any X-Spam-Status/Level IFF we've set a SA value ourselves. Easier than removing - and it leaves
	#them around for diagnosis...
	if ($sa_comment ne "" && $sa_rcpt && /^(X-Spam-Status|X-Spam-Flag|X-Spam-Level|X-Spam-Report):/i) {
	  s/^(X-Spam-Status|X-Spam-Flag|X-Spam-Level|X-Spam-Report):/${V_HEADER}-MOVED-$1:/i;
	}
	if ($sa_comment =~ /^yes/i && $sa_subject ne "" && !/^Subject: \Q$sa_subject\E/i && /^(Subject):(\s?)([^\n]+)\n/i && $sa_rcpt) {
	  $altered_subject="$1: $sa_subject $3";
	  if ($altered_subject !~ /^: \Q$sa_subject\E/) {
	    &debug("q_r: altering subject line to $altered_subject",5);
	    print QMQ "$altered_subject\n";
	    next;
	  }
	}
	$still_headers=0 if (/^(\r|\r\n|\n)$/);
        #Insert Subject: line if e-mail dosn't contain one but must be tagged
        print QMQ "Subject: $sa_subject\n" if ((!$still_headers) && ($sa_comment =~ /^yes/i) && (!$altered_subject) && $sa_subject ne "" && $sa_rcpt);

      }
      print QMQ;
    }
    close(QMQ); #||&error_condition("Unable to close pipe to $qmailqueue (#4.3.0) - $!");
    $xstatus = ( $? >> 8 );
    if ( $xstatus > 10 && $xstatus < 41 ) {
      &error_condition("mail server permanently rejected message. (#5.3.0) - $!",$xstatus);
    } elsif ($xstatus > 0) {
      &error_condition("Unable to open pipe to $qmailqueue [$xstatus] (#4.3.0) - $!",$xstatus);
    }
    #This child is finished - exit
    exit;
  } else {
    # In parent.
    close EOUT;
      
    # Feed the envelope addresses to qmail-queue.
    print EIN "$sender\0$env_recips";
    close EIN  || &error_condition ("Write error to envelope pipe. (#4.3.0) - $!");
}

  # We should now have queued the message.  Let's find out the exit status
  # of qmail-queue.
  waitpid ($pid, 0);
  $xstatus =($? >> 8);
  if ( $xstatus > 10 && $xstatus < 41 ) {
    &error_condition("mail server permanently rejected message. (#5.3.0) - $!",$xstatus);
  } elsif ($xstatus > 0) {
    &error_condition("Unable to close pipe to $qmailqueue [$xstatus] (#4.3.0) - $!",$xstatus);
  }
}


sub valid_virus_to_report {
  my ($virus_type)=@_;
  my ($virus)='';
  # This subroutine is used to determine if the virus found during the scan
  # is reportable. i.e. do we want to send a message to this user or not as is
  # the case with the KLEZ virus.
  #&debug("v_v_t_r: called with $virus_type",5);
  foreach $virus (@silent_viruses_array) {
    #&debug("v_v_t_r: does $virus_type contain $virus?",5);
    if ($virus_type =~ /$virus/i) {
      &debug("v_v_t_r: $virus_type contain '$viru's - so don't notify the sender",3);
      return 0;
    }
  }
  return 1;
}

sub automated_msg {
  if ($headers{'x-loop'} || $headers{'auto-submitted'} !~ /^(|no)$/i || $headers{'x-listname'} || $headers{'x-listmember'} || $headers{'mailing-list'} || $headers{'x-mailing-list'} || $headers{'precedence'} =~ /^(bulk|list|junk)$/i || $returnpath =~ /^$|^\#\@\[\]$|anonymous|nobody|daemon|request|bounce|mailer|postm|owner|list|words|majordom|experts|\-(return|error)/i) {
    return 1;
  } else {
    return 0;
  }
}

sub bounce_msg {
  if ($returnpath =~ /^$|^\#\@\[\]$|(daemon|bounce|mailer|postm)/i) {
    return 1;
  } else {
    return 0;
  }
}

sub is_unreplyable_email {
  my ($addr_type)=@_;
  my ($dom,$is_local)='';
  #This subroutine is used to see if the sender of this message
  #was a mailing-list/postmaster/etc, or the recipient is a local user. 
  #If it is we don't want to send a reply.
  #&debug("i_u_e: called with $addr_type",5);
  
  if ($addr_type eq "recips") {
    foreach $dom (@local_domains_array) {
      #&debug("i_u_e: does $recips contain $dom?",5);
      if ($recips =~ /$dom$/i) {
	#&debug("i_u_e: yes it does!",5);
	$is_local++;
      }
    }
  } else {
    $is_local="99";
    if (&automated_msg ) {
      #&debug("i_u_e: $addr_type is a mailing-list",5);
      return 1;
    }
  }
  #
  #Only reply if it is a local address
  if (!$is_local) {
    #&debug("i_u_e: is_local=$is_local",5);
    return 1;
  } else {
    #&debug("i_u_e: is_local=$is_local",5);
    return 0;
  }
}

sub email_quarantine_report {
  my($start_email_time)=[gettimeofday];
  if ($quarantine_spam) {
    # The following line avoid the quarantining of a message if sa_forward is defined
    # you can comment it if you want the old way
    return if ($sa_forward ne "" && $quarantine_event =~/spam/i && $description !~/potential virus/i);

    # st: now spam is quarantined in a separated directory, but also it is 
    # possible to set a directory per user, so I must check the directory...
    if (! -d "$scandir/quarantine/$smaildir") {
      mkdir("$scandir/quarantine/$smaildir",0750) || &error_condition("cannot create $scandir/quarantine/$smaildir - $!");
      mkdir("$scandir/quarantine/$smaildir/new",0750) || &error_condition("cannot create $scandir/quarantine/$smaildir/new - $!");
      mkdir("$scandir/quarantine/$smaildir/cur",0750) || &error_condition("cannot create $scandir/quarantine/$smaildir/cur - $!");
      mkdir("$scandir/quarantine/$smaildir/tmp",0750) || &error_condition("cannot create $scandir/quarantine/$smaildir/tmp - $!");
    }
    #Use a different maildir for SPAM
    $vmaildir=$smaildir;
    $quarantine_event=$quarantine_spam;
  }elsif ($quarantine_event =~ /^(Policy|Perlscan)/) {
    $destring="policy-violation";
    #Use a different maildir for Policy-blocks
    $vmaildir=$pmaildir;
  }

  # st: if we have multiple recipient quarantine the file once, unless we have differents smaildir...
  return if ( -f "$scandir/quarantine/$vmaildir/new/$file_id");

  if ($vmaildir ne "none") {
    &debug("e_v_r: quarantine  msg to $scandir/quarantine/$vmaildir/new/$file_id",5);
    ### st: if your '$smaildir' resides in a different file system (partition) than
    ### '$wmaildir' comment the next line and uncomment the two following lines.
    # link("$scandir/$wmaildir/new/$file_id","$scandir/quarantine/$vmaildir/new/$file_id")||&error_condition("cannot link $scandir/$wmaildir/new/$file_id into $scandir/quarantine/$vmaildir/new/ - $!");
    copy("$scandir/$wmaildir/new/$file_id","$scandir/quarantine/$vmaildir/new/$file_id")||&error_condition("cannot copy $scandir/$wmaildir/new/$file_id into $scandir/quarantine/$vmaildir/new/ - $!");
  }

  open(QTINE,">>$scandir/quarantine/$vmaildir/new/$file_id");
  print QTINE "\n*** VF-Scanner Quarantine Envelope Details Begin ***\n";
  print QTINE "${V_HEADER}-Mail-From: \"$returnpath\" via $hostname\n";
  print QTINE "${V_HEADER}-Rcpt-To: \"$recips\"\n";
  print QTINE "$V_HEADER: $VERSION ($SCANINFO $destring Found. Processed in ",tv_interval($start_time,[gettimeofday])," secs) process $nprocess \n";
  print QTINE "Quarantine-Description: $quarantine_description\n";
  if (($quarantine_description =~ /spam/i) && $sa_report) {
    print QTINE "SA_REPORT hits = $sa_hits/$required_hits\n$sa_report\n";
  }
  print QTINE "*** VF-Scanner Quarantine Envelope Details End ***\n";
  close QTINE;

  &email_sender("admin");
  if (!$quarantine_spam) {
    &email_sender("sender") if (&valid_virus_to_report($quarantine_description));
    if ($trecips =~ /\0T/) {
      for $recip (split(/\0T/,$trecips)) {
	&email_recips($recip);
      }
    } else {
      &email_recips($recips);
    }
    #This is almost 100% certainly SPAM - no point in notifying anyone
  }
  &write_quarantine_report;
  $elapsed_time = tv_interval ($start_time, [gettimeofday]);
  &debug("e_v_r: email_quarantine_report took " . tv_interval ($start_email_time, [gettimeofday]) . " seconds to execute",5);
}

sub cleanup {
  closelog();
  chdir("$scandir/");
  if ($archiveit !~ /^(1|yes)$/i) {
    #This will only archive mail where the sender or recipient matches the regex that is $archiveit
    if ($headers{'MAILFROM'} !~ /$archiveit/i && $headers{'RCPTTO'} !~ /$archiveit/i) {
      $archiveit=0;
    }
  }
  if (!$archiveit) {
    &debug("cleanup: $rm_binary -rf $ENV{'TMPDIR'}/ $scandir/$wmaildir/new/$file_id",5) ;
  } else {
    # check if $archivedir exists
    if (!-d "$scandir/$archivedir") {
      mkdir("$scandir/$archivedir",0750) || &error_condition("cannot create $scandir/$archivedir - $!");
      mkdir("$scandir/$archivedir/new",0750) || &error_condition("cannot create $scandir/$archivedir/new - $!");
      mkdir("$scandir/$archivedir/cur",0750) || &error_condition("cannot create $scandir/$archivedir/cur - $!");
      mkdir("$scandir/$archivedir/tmp",0750) || &error_condition("cannot create $scandir/$archivedir/tmp - $!");
    }
    if ( -f "$scandir/$wmaildir/new/$file_id" ) {
      &debug("cleanup: archiving into $scandir/$archivedir/new/",2);
      copy("$scandir/$wmaildir/new/$file_id","$scandir/$archivedir/new/$file_id");
      #This will do for now. Not pretty - but very cheap!
      #We need to append this information, otherwise how do you know who this message
      #was from or to?
      #
      open(ARCHIVE,">>$scandir/$archivedir/new/$file_id");
      print ARCHIVE "\n*** VF-Scanner Envelope Details Begin ***\n";
      print ARCHIVE "${V_HEADER}-Mail-From: \"$returnpath\" via $hostname\n";
      print ARCHIVE "${V_HEADER}-Rcpt-To: \"$recips\"\n";
      print ARCHIVE "$V_HEADER: $VERSION ($SCANINFO  Clear:$tag_score$tag_sa_score. Processed in ",tv_interval($start_time,[gettimeofday])," secs)\n";
      if (($quarantine_description =~ /spam/i) && $sa_report) {
        print ARCHIVE "SA_REPORT hits = $sa_hits/$required_hits\n$sa_report\n";
      }
      print ARCHIVE "*** VF-Scanner Envelope Details End ***\n";
      close ARCHIVE;
    } 
  }
  if ($DEBUG < 100 && $file_id ne "") {
    chdir("$scandir/");
    system("$rm_binary -rf $ENV{'TMPDIR'}/ $scandir/$wmaildir/new/$file_id");
  }

}


sub scan_queue {
  my ($scanner,$SCANINFO,$files,$sweep_eng,$sweep_product,$sophie_eng,$dir);
  my $start_scan_time =time;
  my ($inocucmd_eng,$inocucmd_product,$spamassassin_eng);
  
  chdir($scandir);
  &debug("s_q: re-create the quarantine version file",1);
  foreach $scanner (@scanners_installed) {
    $scanner =~ s/_scanner//;
    &debug("s_q: detecting version of $scanner",5);
    if ($scanner eq "uvscan") {
      open(UV,"$uvscan_binary --version|")||die "failed to call $uvscan_binary --version - $!";
      while (<UV>) {
	chomp;
	if (/^Scan engine (v[0-9\.]+) /) {
	  $SCANINFO .="uvscan: $1/";
	} elsif (/^Virus data file (v[0-9\.]+) /) {
	  $SCANINFO .= "$1. ";
	}
      }
      close(UV);
    } elsif ($scanner eq "csav") {
      open(CS,"$csav_binary -virno|")||die "failed to call $csav_binary -virno - $!";
      while (<CS>) {
	chomp;
	if (/Command Software AntiVirus for Linux (version [0-9\.]+)/) {
	  $SCANINFO .="csav: $1/";
	} elsif (/^CSA[V]: (.*)/) {
	  $SCANINFO .= "$1/";
	}
      }
      close(CS);
    } elsif ($scanner eq "trophie" ) {
      open(IS,"$trophie_binary -v 2>&1|")||die "failed to call $trophie_binary -v - $!";
      while (<IS>) {
	chomp;
	if (/VSAPI version (.*)/) {
	  $SCANINFO .= "trophie: $1/";
	} elsif (/Pattern version ([0-9]+) \(pattern number ([0-9]+)\)/) {
	  $SCANINFO .= "$1/$2. ";
	}
      }
      close(IS);
    } elsif ($scanner eq "iscan") {
      open(IS,"$iscan_binary -v|")||die "failed to call $iscan_binary -v - $!";
      while (<IS>) {
	chomp;
	if (/Virus Scanner (v[0-9\.]+), VSAPI (v[0-9\.\-]+)/) {
	  $SCANINFO .="iscan: $1/$2/";
	} elsif (/Pattern version ([0-9\.]+)/) {
	  $SCANINFO .= "$1/";
	} elsif (/Pattern number ([0-9\.]+)/) {
	  $SCANINFO .= "$1. ";
	}
      }
      close(IS);
    } elsif ($scanner eq "fsecure") {
      open(FS,"$fsecure_binary --version|")||die "failed to call $fsecure_binary --version - $!";
      while (<FS>) {
        chomp;
        if (/^F-Secure.*(Release|version)\s+([0-9\.]+)\s+build\s+([0-9]+)/i) {
          $SCANINFO .="fsecure: $2/$3/";
        } elsif (/sign.def version ([0-9\.]+-[0-9\.]+-[0-9\.]+)/) {
          $SCANINFO .= "$1/";
        } elsif (/fsmacro.def version ([0-9\.]+-[0-9\.]+-[0-9\.]+)/) {
          $SCANINFO .= "$1/";
        } elsif (/sign2.def version ([0-9\.]+-[0-9\.]+-[0-9\.]+)/) {
          $SCANINFO .= "$1. ";
        } elsif (/F-PROT database version (.*)$/) {
          $SCANINFO .= "fprot($1)/";
        # Patch for version F-Secure 4.52 by Jyri
        } elsif (/AVP FPI Engine database version (.*)$/) {
          $SCANINFO .= "avp($1). ";
        } elsif (/Libra database version ([0-9\.]+-[0-9\.]+-[0-9\.]+)/) {
          $SCANINFO .= "libra database $1 / ";
        } elsif (/Orion database version ([0-9\.]+-[0-9\.]+-[0-9\.]+)/) {
          $SCANINFO .= "orion database $1 / ";
        } elsif (/AVP FPI Engine database version ([0-9\.]+-[0-9\.]+-[0-9\.]+)/) {
          $SCANINFO .= "avp fpi database $1. ";
        }
      }
      close(FS);
      $SCANINFO .= ". " if ($SCANINFO !~ /\. $/);
    } elsif ($scanner eq "fpscand" || $scanner eq "fpscan") { 
      open(FP,"$fpscan_binary \?|")||die "failed to call $fpscan_binary --version - $!";
      while (<FP>) {
	chomp;
	if (/(F-PROT Antivirus version:?) ([0-9\.]+)/) {
	  $SCANINFO .="f-prot: $2/";
	} elsif (/Engine version: ([0-9\.]+)/) {
	  $SCANINFO .= "$1";
	}
      }
      $SCANINFO .= ". ";
      close(FP);
    } elsif ($scanner eq "hbedv") {
      open(IS,"$hbedv_binary --version 2>&1 |")||die "failed to call  $hbedv_binary --version - $!";
      while (<IS>) {
	chomp;
	if (/engine version:\s+([0-9\.]+)/) {
	  $SCANINFO .= "hbedv: $1";
	} elsif (/vdf version:\s+([0-9\.]+)/) {
	  $SCANINFO .= "/$1. ";
	}
      }
      close(IS);
    } elsif ($scanner eq "avp") {
      open(AVP,"$avp_binary -Y -VL 2>&1 |")||die "failed to call  $avp_binary -Y -VL  - $!";
      while (<AVP>) {
	chomp;
	if (/Version (([0-9\.]+)\s+build ([0-9\.]+)|([0-9\.]+))/) {
	  if ($2) {
	    $SCANINFO .= "avp: $1/$2. ";
	  } else {
	    $SCANINFO .= "avp: $1. ";
	  }
	}
      }
      close(AVP);
    } elsif ($scanner eq "ravlin") {
      open(RAV,"$ravlin_binary --version 2>&1 |")||die "failed to call  $ravlin_binary --version  - $!";
      while (<RAV>) {
	chomp;
	if (/^Version: ([0-9\.]+)\./) {
	  $SCANINFO .= "ravlin: $1. ";
	}
      }
      close(RAV);
    } elsif ($scanner eq "avast") {
      open(AVAST,"$avastcmd_binary -V 2>&1|")||die "failed to call $avastcmd_binary -V - $!";
      while (<AVAST>) {
        chomp;
       if (/^avastcmd: avastcmd (v[0-9\.]+)/) {
        $SCANINFO .= "avast: $1/";
       }elsif (/^VPS: ([^\s]+)\s/) {
        $SCANINFO .= "$1. ";
       }
      }
      close(AVAST);
    } elsif ($scanner eq "vexira") {
      open(VEX,"$vexira_binary --version 2>&1 |")||die "failed to call  $vexira_binary --version  - $!";
      while (<VEX>) {
	chomp;
	if (/^engine version:\s+([0-9\.]+)/) {
	  $SCANINFO .= "vexira: $1. ";
	}
      }
      close(RAV);
    } elsif ($scanner eq "bitdefender") {
      open(BITDEF,"$bitdefender_binary --info 2>&1 |")||die "failed to call $bitdefender_binary --info - $!";
      while(<BITDEF>) {
	chomp;
	if (/^BDC\/Linux\-Console (.*) \(build ([^\)]+)\)/){
	  $SCANINFO .= "bitdefender: $1/$2";
	}
	if (/^Engine signatures:\s+([0-9]+)/) {
	  $SCANINFO .= "/$1. ";
	}
      }
      close(BITDEF);
    } elsif ($scanner eq "nod32") {
      open(NOD,"$nod32_binary --version 2>&1 |")||die "failed to call $nod32_binary --version - $!";
      while(<NOD>) {
	chomp;
	if (/\s(\d\S+)\s*$/){
	  $SCANINFO .= "nod32: $1 ";
	}
      }
      close(NOD);
    } elsif ($scanner eq "esets") {
      open(ESET,"$esets_binary --version 2>&1 |")||die "failed to call $esets_binary --version - $!";
      while(<ESET>) {
	chomp;
	if (/\s(\d\S+)\s*$/){
	  $SCANINFO .= "esets: $1 ";
	}
      }
      close(ESET);
    } elsif ($scanner eq "sophie") {
      open(SOP,"$sophie_binary -v 2>&1|")||die "failed to call $sophie_binary -v - $!";
      while (<SOP>) {
	chomp;
	if (/Sophos engine version (.*)$/) {
	  $sweep_eng=$1;
	} elsif (/Sophos IDE version ([0-9\.]+)/) {
	  $sweep_product=$1;
	} elsif (/Sophie version\s+:\s+([0-9\.]+)/) {
	  $sophie_eng=$1;
	}
      }
      $SCANINFO .= "sophie: $sophie_eng/$sweep_eng/$sweep_product. ";
      close(SOP);
    } elsif ($scanner eq "savscan") {
      open(SOP,"$savscan_binary -v|")||die "failed to call $savscan_binary  -v - $!";
      while (<SOP>) {
	chomp;
	if (/Engine version\s+:\s+(.*)$/) {
          $sweep_eng=$1;
        } elsif (/Product version\s+:\s+(.*)$/) {
          $sweep_product=$1;
        }
      }
      $SCANINFO .= "savscan: $sweep_eng/$sweep_product. ";
      close(SOP);
    } elsif ($scanner eq "sweep") {
      open(SOP,"$sweep_binary -v|")||die "failed to call $sweep_binary -v - $!";
      while (<SOP>) {
	chomp;
	if (/Engine version\s+:\s+(.*)$/) {
	  $sweep_eng=$1;
	} elsif (/Product version\s+:\s+(.*)$/) {
	  $sweep_product=$1;
	}
      }
      $SCANINFO .= "sweep: $sweep_eng/$sweep_product. "; 
      close(SOP);
    } elsif ($scanner eq "inocucmd") {
      open(IOP,"$inocucmd_binary -HEL|")||die "failed to call $inocucmd_binary -HEL - $!";
      while (<IOP>) {
	chomp;
	if (/Engine version:\s+(.*) ([0-9\/]+)$/) {
	  $inocucmd_eng=$1;
	} elsif (/Data version:\s+(.*) ([0-9\/]+)$/) {
	  $inocucmd_product=$1;
	}
      }
      $SCANINFO .= "inocucmd: $inocucmd_eng/$inocucmd_product. ";
      close(IOP);
    } elsif ($scanner eq "clamscan") {
      open(CLAMS,"$freshclam_binary -V|")||die "failed to call $freshclam_binary -V - $!";
      while (<CLAMS>) {
	chomp;
	if (/ClamAV ([0-9\.\/]+)\//) {
	  $SCANINFO .="clamscan: $1. ";
	}
      }
      close(CLAMS);
    } elsif ($scanner eq "clamdscan") {
      open(CLAMS,"$freshclam_binary --version 2>&1|")||die "failed to call $freshclam_binary --version - $!";
      while (<CLAMS>) {
	chomp;
	if (/ClamAV ([0-9\.\/]+)\//) {
	  $SCANINFO .="clamdscan: $1. ";
	}
      }
      close(CLAMS);
    } elsif ($scanner eq "spamassassin") {
      #X-Spam-Checker-Version: SpamAssassin 2.01
      open(SPAS,"$spamassassin_binary  -V |")||die "failed to call $spamassassin_binary -V - $!";
      $spamassassin_eng="2.x";
      while (<SPAS>) {
	chomp;
	if (/^SpamAssassin version (.*)$/i) {
	  $spamassassin_eng=$1;
	}
      }
      close(SPAS);
      $SCANINFO .= "spamassassin: $spamassassin_eng. ";
    } elsif ($scanner eq "perlscan") {
      $SCANINFO .="perlscan: $VERSION. ";
    } else {
      #Catch-all for other ones
      $SCANINFO .= "$scanner: ???. ";
    }
  }
  $SCANINFO =~ s/ \. / /g;
  open(VER,">$versionfile.tmp")||die "cannot write to $versionfile.tmp - $!";
  print VER $SCANINFO;
  close(VER);
  rename("$versionfile.tmp","$versionfile");
  &debug("s_q: cleaning up files older than 2 days via $find_binary $scandir/tmp -mtime +2 -exec $rm_binary -rf {} \;",1);
  my ($OLDFILES)=`$find_binary $scandir/tmp -mtime +2 -exec $rm_binary -rf {} \\; 2>/dev/null`;
  &debug("s_q: cleaning up quarantined mail older than 14 days via $find_binary $scandir/quarantine -type f -mtime +14 -exec $rm_binary -rf {} \;",1);
  $OLDFILES=`$find_binary $scandir/quarantine/ -type f -mtime +14 -exec $rm_binary -f {} \\; 2>/dev/null`;
}

sub write_quarantine_report {
  my ($temp,$desc,$report,$subj);
  $subj=$headers{'subject'};
  $subj =~ s/\t/ /g;
  $desc=$quarantine_description;
  $desc =~ s/\n\t/ /g;
  $nowtime = strftime("%a, %d %b %Y %H:%M:%S %Z", localtime(time));
  $report = "$nowtime\t$returnpath\t$recips\t$subj\t$desc\t$SCANINFO\n";
  open(QUARANTINELOG,">>$logdir/$quarantinelog");
  print QUARANTINELOG $report;
  close QUARANTINELOG;
  &debug("w_v_r: writing quarantine log report of: $report",5);
}

sub scanner_info {
  open(SC,"<$versionfile")||&error_condition("cannot read $versionfile - did you initialise the system by running \"$prog -z\"? - $!");
  $SCANINFO = <SC>;
  $SCANINFO =~ s/\n|\r|\0/ /g;
  close(SC);
}

sub generate_quarantine_db {
  # use DB_File;
  use vars qw( %h);
  my ($tfile, $line,%array,$count,$match,$type,$descr,$entry,$descrip,$size);
  if ($opt_g) {
    print "perlscanner: generate new DB file from $db_filename.txt\n";
   # delete "__db.[DBNAME]" and "__db.[DBNAME].*"
   foreach $tfile ("$db_filename.db.tmp", "__db.$db_filename.db.tmp", <__db.$db_filename.db.tmp.*>) {
     next unless (-e $tfile);
     if (!unlink($tfile)) {
	print "ERROR: cannot remove Berkeley DB tmp file $tfile: $!\n";
	&error_condition("ERROR: cannot remove Berkeley DB tmp file $tfile: $!");
     }
    }
    tie (%array, 'DB_File', "$db_filename.db.tmp", O_CREAT|O_RDWR, 0640, $DB_HASH ) || &error_condition("cannot write to $db_filename.db.tmp - $!");
    
    open(TXT,"<$db_filename.txt")||&error_condition("cannot read $db_filename.txt - $!");

    #Remeber: all filenames are lowercased, but headers aren't...
    while (<TXT>) {
      $line++;
      next if (/^\#|^\s+$/); #ignore lines starting with hashes
      chomp;
      $count++;
      ($match,$type,$descr)=split(/\t+/,$_,3);
      if ( $match eq "" || ($type !~ /^SIZE=(\-|\<|\>|)[0-9]+$/ && $type !~ /^Policy-[0-9a-z\_\-]+:$/i) ) {
	print "ERROR: incorrect format on line \"$line\"\n";
	&error_condition("ERROR: incorrect format on line \"$line\"");
      } else {
	#Strip off any regex endings
	if ($type =~ /^SIZE=(|\-|\<|\>)[0-9]+$/) {
	  #this is a filename/attachment
	  if ( $match =~ /^\.dat$/i ) {
	    
	    print "ERROR: on line \"$line\".\nCannot block all .dat files. Will block too many normal messages.\n";
	    &error_condition("ERROR: on line \"$line\".\nCannot block all .dat files. Will block too many normal messages.");
	    next;
	  }
	  $match = tolower($match);
	} else {
	  #this is for header matches
	  $match =~ s/^\^|\$$//g;
	  #Now make unique
	  $match = "$line:$match";
	  $type =~ s/:$//;
	}
	$array{"$match"}="$type\t$descr";
      }
    }
    close(TXT);
#    $array->sync;
    untie %array ;
    rename("$db_filename.db.tmp","$db_filename.db");
    print "perlscanner: total of $count entries.\n";
  } else {
    print "perlscanner: reading from $db_filename.db\n";
    tie (%array, 'DB_File', "$db_filename.db", O_RDONLY, 0600) || &error_condition("cannot read $db_filename.db - $!");
    foreach $entry (keys %array) {
      $count++;
      ($type,$descrip)=split(/\t/,$array{$entry},2);
      if ( $type =~ /^SIZE=((\-|\<|\>|)[0-9]+)/) {
	if ($type eq "SIZE=-1") {
	  $type="Any";
	} elsif ($type =~ /^SIZE=((\-|\<|\>|)[0-9]+)$/) {
	  $type="$1 bytes";
	}
	print "File: \t$entry\n\t\t\tSize: $type\n\t\t\tDescription: $descrip\n\n";
      }
      if ($type =~ /^Policy-(.*)$/i) {
	$type=$1;
	#Strip off numeric uid...
	$entry =~ s/^[0-9]+://;
	if (grep(/^$type$/,@virtualheaders_array)) {
	  print "Virtual Header: \t$type\n\t\t\tContent: ^$entry\$\n\t\t\tDescription: $descrip\n\n";
	} else {
	  print "Email Header: \t$type\n\t\t\tContent: ^$entry\$\n\t\t\tDescription: $descrip\n\n";
	}
      }
    }
    untie %array;
    print "perlscanner: total of $count entries found.\n";
  }
}




sub show_version {
  my ($scanner);
  &scanner_info;
  print "

$prog

Version: $VERSION ($st_version)

Perl:    Summary of my perl5 (revision 5 version 8 subversion 8) configuration:\n\n";

  if ($settings_pd && $opt_V) {
     print "Settings per domain: enabled\n\n";
  } else {
     print "Settings per domain: disabled\n\n" if ($opt_V);
  }

  print "Scanners installed: ";
  foreach $scanner (@scanners_installed) {
    print " $scanner, ";
  }

  if ($settings_pd && $opt_V) {
     print "\n\nScanners default:   ";
     foreach $scanner (@scanners_default) {
       print " $scanner, ";
     }
  }

  print "\n\nScanner versioning:  $SCANINFO\n";

  if ($spamc_binary =~ /spamc/ && $opt_V) {
     print "\nSpamassassin settings:\n";
     if ($sa_fast || $sa_alt) {
        print "   Mode:   fast_spamassassin\n";
     } else {
        print "   Mode:   verbose_spamassassin\n";
     }
     print "   sa_timeout = $sa_timeout / sa_fault_tolerant = $sa_ft / sa_maxsize = $sa_maxsize\n";
     if ($sa_alt) {
        print "   sa_alt: enabled / sa_debug = $sa_debug / sa_hdr_report_site = $sa_hdr_report_site\n";
     }
     if ($sa_forward_site) {
        print "   sa_forward_site = '$sa_forward_site' / sa_fwd_verbose_site = $sa_fwd_verbose_site\n";
     }
     print "   sa_subject_site    = '$sa_subject_site'\n";
     print "   sa_delta_site      = $sa_delta_site\n";
     print "   sa_quarantine_site = $sa_quarantine_site\n";
     print "   sa_delete_site     = $sa_delete_site / sa_reject_site = $sa_reject_site\n";
  }

  print "
Operating System: $sysname, $release
Hardware:         $machine";
  print "\n\n\n";
}


sub email_sender {
  #Don't e-mail bounced mail messages/etc!
  return if (&is_unreplyable_email('sender'));
  my($addr_type)=@_;
  my ($HDR,$hdr,$tmpsndrs,$tmpsubj,$polstring)='';
  my ($tmpmsgid)= &uniq_id() . "-" . $V_FROM;
  $polstring='policy' if (&notify_addr('nmlvadm'));

  open(SM,"|$qmailinject -h -f ''")||&error_condition("cannot open $qmailinject for sending quarantine report - $!");
  print SM "From: \"$V_FROMNAME\" <$V_FROM>\n";
  if ($addr_type =~ /sender/) {
    $addr_type='psender' if ($NOTIFY_ADDRS =~ /psender/);
    if ($addr_type eq "sender") {
      if (!&is_unreplyable_email('sender') && &notify_addr('sender')) {
	&debug("e_s: sending quarantine report via: $qmailinject to sender address ($returnpath)",5);
	print SM "To: $returnpath\n";
	$tmpsndrs = "$returnpath";
      } else {
	&debug("e_s: don't notify sender",5);
      }
    } elsif ($addr_type eq "psender") {
      if (!&is_unreplyable_email('sender') && &notify_addr('sender') && ($quarantine_event =~ /^(policy|perlscan)/i && $quarantine_event !~ /(gr[ae]ylist|virus)/i)) {
	&debug("e_s: sending policy quarantine report via: $qmailinject to psender address ($returnpath)",3);
	print SM "To: $returnpath\n";
	$tmpsndrs = "$returnpath";
      } else {
	&debug("e_s: don't notify psender",5);
      }
    } else {
      return;
    }
  } else {
    # st: if the mail is local and is set nmladm or nmlvadm,
    # always notify admin (maybe it is not good or a big site)
    if ( &notify_addr('admin') || ( &notify_addr('nmladm') && (!&is_unreplyable_email('sender') || $QS_RELAYCLIENT) ) || ( &notify_addr('nmlvadm') && (($quarantine_event =~ /^(policy|perlscan)/i && $quarantine_event !~ /(gr[ae]ylist|virus)/i && !&is_unreplyable_email('sender')) || $QS_RELAYCLIENT) ) ) {
      &debug("e_s: sending $polstring quarantine report via: $qmailinject to admin address ($QUARANTINE_CC)",3);
      print SM "To: $QUARANTINE_CC\n";
      $tmpsndrs .= "$QUARANTINE_CC";
    } else {
      &debug("e_s: don't notify admin",5);
    }
  }
  $tmpsubj="$destring found in sent message \"$headers{'subject'}\"";
  $tmpsubj =~ s/(\r|\0|\n)/ /g;
  if ($QS_RELAYCLIENT) {
     print SM "Subject: LOCAL USER - $tmpsubj\n";
  } else {
     print SM "Subject: $tmpsubj\n";
  }
  print SM "Message-ID: <".&uniq_id."\@$hostname>\n";
  print SM "Auto-Submitted: auto-replied\n";
  if ($headers{'message-id'} ne "") {
    print SM "In-Reply-To: ",$headers{'message-id'},"\n";
    print SM "References: ",$headers{'message-id'},"\n";
  }
  print SM "MIME-Version: 1.0\n";
  print SM "Content-type: text/plain\n";
  print SM "Content-Transfer-Encoding: 8bit\n";
  #Only add these headers for Internet-incoming
  if ( $descriptive_hdrs && !$QS_RELAYCLIENT) {
    print SM "${V_HEADER}-Mail-From: $returnpath via $hostname\n";
    print SM "${V_HEADER}-Rcpt-To: $recips\n" if ($descriptive_hdrs eq "2");
    print SM "$V_HEADER: $VERSION ($SCANINFO $destring Found. \n";
    print SM " Processed in ",tv_interval($start_time,[gettimeofday])," secs)\n";
  }
  print SM "\n";
  if (&is_unreplyable_email('sender')) {
    print SM "
Attention: $V_FROMNAME.\n";
    print SM "
[This warning message is *not* being sent to the apparent originator
of the original message.  This address appears to be that of a
mailing list or other automated email system.]\n";
    print SM "\n---------------------------------------\n\n";
  } else {
    print SM "
Attention: $returnpath\n";
  }
  print SM "\n
A $destring was found in an Email message you sent. 
This Email scanner intercepted it and stopped the entire message
reaching its destination. 

The $destring was reported to be: 

$quarantine_description\n";
  if (($addr_type !~ /sender/) && ($quarantine_description =~ /spam/i) && $sa_report) {
    print SM "\nSA_REPORT hits = $sa_hits/$required_hits\n$sa_report\n\n";
  }
  if ($destring eq "virus") {
    print SM "\n
Please update your virus scanner or contact your IT support 
personnel as soon as possible as you may have a virus on your system.\n";
  } else {
    print SM "\n
Please contact your IT support personnel with any queries regarding this 
policy.\n";
  }
  print SM "\n
Your message was sent with the following envelope:

MAIL FROM: $returnpath
RCPT TO:   $recips 

... and with the following headers:\n\n";
  print SM "---\n";
  print SM "MAILFROM: $headers{'MAILFROM'}\n";
  print SM "RCPTTO: $headers{'RCPTTO'}\n";
  print SM "IP-Addr: $headers{'REMOTEIPADDR'}\n";
  print SM "$HEADERS\n";
  print SM "---\n";
  if ($addr_type !~ /sender/ ) {
    print SM "\n

The original message is kept in:

  $hostname:$scandir/quarantine/$vmaildir/new/$file_id

where the $V_FROMNAME can further diagnose it.

The Email scanner reported the following when it scanned that message:

--- 
$description
---\n";
  }
  close(SM);
#  if ($log_details) {
#    &log_msg("VF-scanner","Clear:RC:1(127.0.0.1):",$elapsed_time,1100,$V_FROM,$tmpsndrs,$tmpsubj,$tmpmsgid,"quarantine-event.txt:1000");
#  }
}

sub email_recips {
  my($recip)=@_;
  return if ($recip eq "");
  #Don't notify precips if this is NOT a "Policy block"
  if (&notify_addr('precips')) {
    return if ($quarantine_event !~ /^(policy|perlscan)/i);
  } else {
    #From now on precips is the same as recips
    $NOTIFY_ADDRS=~s/precips/recips/;
  }
  return if (!&notify_addr('recips'));
  my($HDR,$hdr,$tmprecips,$tmpsubj)='';
  my($tmpmsgid)= &uniq_id() . "-" . $V_FROM;

  open(SM,"|$qmailinject -h -f ''")||&error_condition("cannot open $qmailinject for sending quarantine report - $!");
  print SM "From: \"$V_FROMNAME\" <$V_FROM>\n";
  if (!&is_unreplyable_email('recips')) {
    &debug("e_r: sending quarantine report via: $qmailinject to recip address ($recip)",5);
    print SM "To: $recip\n";
  }
  $tmpsubj= "$destring found in received message \"$headers{'subject'}\"";
  $tmpsubj =~ s/(\r|\0|\n)/ /g;
  print SM "Subject: $tmpsubj\n";
  print SM "Message-ID: <".&uniq_id."\@$hostname>\n";
  if ($headers{'message-id'} ne "") {
    print SM "In-Reply-To: ",$headers{'message-id'},"\n";
    print SM "References: ",$headers{'message-id'},"\n";
  }
  print SM "Auto-Submitted: auto-replied\n";
  print SM "MIME-Version: 1.0\n";
  print SM "Content-type: text/plain\n";
  if ( $descriptive_hdrs ) {
    print SM "${V_HEADER}-Mail-From: $returnpath via $hostname\n";
    print SM "${V_HEADER}-Rcpt-To: $recip\n" if ($descriptive_hdrs eq "2");
    print SM "$V_HEADER: $VERSION ($SCANINFO $destring Found. \n";
    print SM " Processed in ",tv_interval($start_time,[gettimeofday])," secs)\n";
  }
  print SM "\n";
  print SM "
Attention: $recip\n";
  if (!&is_unreplyable_email('recips')) {
    if (&notify_addr('sender')) {
      print SM "
[A message has been sent to the originator, stating there is a virus
in the Email they just sent to you. No further action is required on
your part.]\n";
    }
  } else {
    print SM "

[This message was _not_ sent to the originator address, as that appears to
be a mailing-list or some other automated Email message]\n";
  }
  print SM "\nA $destring was found in an Email message sent to you. 
This Email scanner intercepted it and stopped the entire message
before it reached you. No further action is required on your part.\n";
  print SM "\nThe $destring was reported to be: 

$quarantine_description

Please contact your IT support personnel with any queries regarding this 
policy.

The message sent to you had the following envelope:

MAIL FROM: $returnpath
RCPT TO:   $recips 

... and with the following headers:\n\n";
  print SM "---\n";
  print SM "MAILFROM: $headers{'MAILFROM'}\n";
  print SM "RCPTTO: $headers{'RCPTTO'}\n";
  print SM "IP-Addr: $headers{'REMOTEIPADDR'}\n";
  print SM "$HEADERS\n";
  print SM "---\n";
  #print SM "\nLxOCALE_recips_quarantine\n";
  close(SM);
#  if ($log_details) {
#    &log_msg("VF-scanner","Clear:$tag_score$tag_sa_score",$elapsed_time,1100,$V_FROM,$recip,$tmpsubj,$tmpmsgid,"quarantine-event.txt:1000");
#  }
}

sub notify_addr {
  my($addr_type)=@_;
  #&debug("n_a: notify_addr (set to $NOTIFY_ADDRS) called with $addr_type",5);
  if (($NOTIFY_ADDRS =~ /$addr_type/ || $NOTIFY_ADDRS =~ /all/) && ($NOTIFY_ADDRS !~ /none/)) {
    return 1;
  } else {
    return 0;
  }
}

sub unzip_file {
  my($zipfile)=@_;
  my ($MAYBEZIP,$ztmp,$zfile,$zline,$zsize,$zip_status);
  
  &debug("u_f: potential zip archive file found ($zipfile).",5);
  &debug ("u_f: it is possibly a zip file, run unzip $unzip_options -t $ENV{'TMPDIR'}/$zipfile",5);
  $MAYBEZIP=`$unzip_binary $unzip_options -t $ENV{'TMPDIR'}/$zipfile 2>&1`;
  $zip_status=($? >> 8);
  
  if ( ($zip_status > 0) && ($zip_status !~ /^(1|2|3|51|81|82)$/) && ($MAYBEZIP !~ /skipping: /) ) {
    &debug("u_f: not a recognisable zip file ($MAYBEZIP)",5);
  } else {
    &debug ("u_f: it is a zip file",5);
    if ($MAYBEZIP =~ /skipping:.*password/) {
      &debug("u_f: it is a password-protected zip file",1);
      $CRYPTO_TYPE="CR:ZIP(encrypted)";
    }
    if ($force_unzip) {
      &debug("u_f: check size of contents before unzipping to disk",5);
      my $CHECK_ZIP_SIZE=`$unzip_binary $unzip_options -lv $ENV{'TMPDIR'}/$zipfile 2>&1`;
      open(ZIPPED,"$unzip_binary $unzip_options -lv  $ENV{'TMPDIR'}/$zipfile 2>&1|")||&error_condition("u_f: cannot open $ENV{'TMPDIR'}/$zipfile - $!");
      my $zip_file_size=0;
      while (<ZIPPED>) {
	$zip_file_size=$1 if (/^\s+([0-9]+)\s+/);
      }
      close ZIPPED ;
      &debug("u_f: this zip file unpacks to $zip_file_size bytes of content",5);
      if ($max_zip_size > 0 && $max_zip_size < $zip_file_size) {
	$quarantine_description="Disallowed zip file ($zipfile) - content exceeds maximum allowed size";
	&debug("u_f: $quarantine_description",1);
	$destring='problem';
	$quarantine_event="Policy:Oversized_ZIP";
	$quarantine_DOS=$quarantine_event;
	$description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found in file $ENV{'TMPDIR'}/$zipfile";
	$file_desc .= "oversized_zip:$msg_size\t";
	return;
      }
      &debug("u_f: run $unzip_binary $unzip_options $ENV{'TMPDIR'}/$zipfile 2>&1",5);
      open(ZIPPED,"$unzip_binary $unzip_options   $ENV{'TMPDIR'}/$zipfile 2>&1|")||&error_condition("u_f: cannot open $ENV{'TMPDIR'}/$zipfile - $!");
      while (<ZIPPED>) {
	if (/^\s+\w+:\s+(.*)$/) {
	  ($ztmp=$1)=~s/^.*\///g;
	  #Grrr, I don't know if this'll be exploited, but I have to remove the whitespace...
	  #$ztmp=~s/\s+$//g;
	  #if ($ztmp ne "" && !grep(/^${ztmp}$/,@zipfile_list)) {
	  #&debug("u_f: adding file '$ztmp' to list of zipped files",5);
	  #push(@zipfile_list, $ztmp);
	  #}
	}
	if (/^\s+skipping:\s(.*)\s+(shrink|encrypted|incorrect password)/) {
	  $passwd_protected_zip++ if (!/^\s+skipping:\s(.*)\s+shrink/);
	  #grab these protected filenames for reports anyway.
	  $zfile = $1;
	  $zfile =~ s/^.*\///g;
	  $zfile =~ s/(^\s+|\s+$)//g;
	  #$file_desc .= "$zfile:$zsize\t";
	}
	close(ZIPPED);
	$zip_status=($? >> 8);
	if ($zip_status > 0 && ($zip_status !~ /^(1|2|3|51|81|82)$/ && !$passwd_protected_zip)) {
	  &error_condition("u_f: cannot close unzip (error code: $zip_status,$passwd_protected_zip) - $!");
	}
      }
    }
    #Only delete original zip file if it happily unpacked.
    if ( $zip_status eq 0 && -f "$ENV{'TMPDIR'}/$zipfile") {
	#system $rm_binary,"-f","$ENV{'TMPDIR'}/$zipfile";
	&debug("u_f: $zip_status, and successfully unzipped",5);
	#It may have been deleted, but you still want to see if 
	#it matches the perlscanner DB...
	#$zipfile=tolower($zipfile);
	#push(@zipfile_list, $zipfile) if (!grep(/^$zipfile$/,@zipfile_list));
	my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$zsize,$atime,$mtime,$ctime,$blksize,$blocks);
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$zsize,$atime,$mtime,$ctime,$blksize,$blocks) = stat("$zipfile");
	$file_desc .= "$zipfile:$zsize\t";
	#Now ensure the permissions are opened up to 0740
	my $xchmod=`chmod -R 750 . 2>&1`;
	&debug("u_f: using chmod to ensure files are readable ($xchmod)",5);
    } 
  }
}

sub deltatime {
  my ($delta,$current_time);
  $current_time = [gettimeofday];
  $delta =  tv_interval ($last_time, $current_time);
  $last_time=$current_time;
  return $delta;
}

sub qmail_parent_check {
  my $ppid=getppid;
  #&debug("q_s_c: PPID=$ppid",5);
  if ($ppid == 1)  {
    &debug("q_s_c: Whoa! parent process is dead! (ppid=$ppid) Better die too...",1);
    &cleanup;
    &close_log;
    #Exit with temp error anyway - just to be real anal...
    exit 111; 
  }
}


sub check_and_grab_attachments {
  #This subroutine find attachments (e.g., MIME/binhex,uuencode) within e-mails

  if (/^MIME-Version:/i || ($headers{'content-type'} ne "" && $headers{'content-type'} !~ /^text\/plain/i)) {
    $indicates_attachments++;
    &debug("c_a_g: found MIME attachment",5) if ($indicates_attachments == 2);
  }
  #This finds MIME messages banged onto the bottom of bounces
  if (/^\-+ (Below this line|This) is a copy of the message/) {
    $indicates_attachments += 2;
    &debug("c_a_g: found hidden MIME attachment",2) if ($indicates_attachments == 2);
  }
  #This will define any text mail that contains a URL as requiring scanning - otherwise
  #some phishing attacks will geet past
  if ($indicates_attachments < 2 && /http:\/\/|www\.|[a-z0-9\-]+\.[a-z0-9\-]+\//i) {
    $indicates_attachments += 2;
    &debug("c_a_g: found URL in message - maybe phishy - better scan it",3);
  }
  #This finds BinHex attachments
  if (/^\(This file must be converted with BinHex/) {
    $indicates_attachments += 2;
    &debug("c_a_g: found hidden BinHex attachment",2) if ($indicates_attachments == 2);
  }
  my ($begin,$perms,$uufile,$uuextension,$uulength,$uuencoded_attachments,$begin_content);
  if (/^(begin) ([0-9][0-9][0-9]) (.*)\n$/) {
    &debug("c_a_g: Ooohhhh, a uuencoded attachment!",3);
    #Better reset this message back to potentially having attachments
    $plain_text_msg=0;
    $uuencoded_attachments++;
    $begin=$1;
    $perms=$2;
    $uufile=tolower($3);
    push(@uufile_list, $uufile) if(!grep(/^$uufile$/,@uufile_list));
    $uufile=~s/[^0-9a-z\_\-\.]/_/gi;
    $uufile =~ /\.([^\.]+)$/;
    $uuextension=$1;
    #Ensure the file extension isn't too long either...
    $uuextension=substr($uuextension,0,20); 
    $uulength=length($uufile);
    #Ensure the filelength isn't too large!
    if ( $uulength > $MAX_FILE_LENGTH) {
      &debug("uudecode output: gah! filename is > $MAX_FILE_LENGTH (actually $uulength), chopping...",2);
      $uufile=substr($uufile,0,$MAX_FILE_LENGTH).".".$uuextension;
    }
    return if (!$uudecode_binary);
    if (! -f "$ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile.uue") {
      open(UUIN,">$ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile.uue")||&error_condition("cannot open $ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile.uue - $!");
    } else {
      &error_condition("$ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile.uue already exists! - $!");
    }
    print UUIN "$begin 640 $uufile\n";
    print TMPFILE;
    $begin_content = "uuencode";
    while (<STDIN>) {
      if ($begin_content eq "uuencode" && $_ =~ /^(M35JJ|M35J0|M35KU|M35H\\|M35HN)/i) {
	&debug("w_c: looks like a Windows executable, filename=$uufile",5);
      }
      print UUIN;
      print TMPFILE;
      if (/^end/) {
	close(UUIN)||&error_condition("cannot close $ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile - $!");
	#uudecode it - toss away the error code - who cares if it's broken...
	&debug("c_a_g_u: $uudecode_binary $uudecode_pipe $ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile.uue",5);
	if (! -f  "$ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile") {
	  system("$uudecode_binary -o $ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile $ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile.uue 2>/dev/null");
	  rename("$ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile","$ENV{'TMPDIR'}/$uufile") if (!-f "$ENV{'TMPDIR'}/$uufile");
	} else {
	  &error_condition("$ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile already exists! - $!");
	}
	#open(UUOUT,"$uudecode_binary $uudecode_pipe $ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile.uue|");
	#open(UUFILE,">$ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile");
	#while (<UUOUT>) {
	  #print UUFILE;
	#}
	#close UUOUT;
	#close UUFILE;
	&debug("deleting uuencoded file as we have a decoded version of it now",5);
	unlink("$ENV{'TMPDIR'}/$file_id-$uuencoded_attachments-$uufile.uue") if ($DEBUG < 100);
	last;
      }
    }
  }
}

sub log_msg {
  my($msgtype,$status,$elapsed_time,$msgsize,$frm,$recips,$subj,$msgid,$attachs)=@_;
  my ($msg,$file);


  my $syslogtype='mail|info';

  if ($log_details eq "syslog") {

    $msgtype =~ s/\s/_/g;
    $msgtype .= "[$$]";
    $status =~ s/\s//g;
    $syslogtype='mail|warning' if ($status !~ /^Clear/);
    $elapsed_time =~ s/\s//g;
    $elapsed_time=0.0 if (!$elapsed_time);
    $elapsed_time=substr($elapsed_time,0,8);
    $frm =~ s/\s/_/g;
    $frm='<>' if (!$frm);
    $frm=substr($frm,0,100);
    $recips =~ s/\s/\|/g;
    $recips='<>' if (!$recips);
    $recips=substr($recips,0,100);
    $subj =~ s/\s/_/g;
    $subj='<>' if (!$subj);
    $subj=substr($subj,0,80);
    $msgid =~ s/\s/_/g;
    $msgid = '<>' if (!$msgid);
    $msgid=substr($msgid,0,80);
    $msgsize =~ s/\s//g;
    $attachs =~ s/\s$//g;
    #Sub any spaces for underscores then swap tabs for spaces,
    #syslog doesn't like tabs, so spaces in filenames have to go...
    $attachs =~ s/\ /_/g;
    $attachs =~ s/\t/ /g;
    if (!$attachs) {
      foreach $file (@uufile_list,@zipfile_list,@attachment_list) {
	$file =~ s/\s/_/g;
	$attachs .= "$file ";
      }
      $attachs =~ s/\s+$//g;
    }
    $attachs="$file_id-unpacked:$msg_size" if (!$attachs);
    #$attachs=substr($attachs,0,100);
    $msg = "$status $elapsed_time $msgsize $frm $recips $subj $msgid $attachs";
    #Do final santity check and remove all low-end chars - like NULL
    #I have no idea how some older syslogs would react to such things...
    $msg =~s/[\x00-\x09]//g;
    $msg =~ s/%/%%/g;
    #Now ensure syslog record isn't larger than max syslog size of 1024 chars
    $msg=substr($msg,0,1024);
    eval {
      $SIG{ALRM} = sub { die "Maximum time writing to syslog exceeded. syslog is hung/broken." };
      alarm 10;
      eval {
	syslog($syslogtype,"$msgtype: $msg");
      };
      if ($@) {
	setlogsock('inet');
	syslog('mail|info',"$msgtype: $msg");
      }
    };
    #The message is delivered - so no temp failure here - you just have to lose the log entry...
    alarm 0;
  } else {
    #No error checking - inability to write a log report shouldn't
    #stop the mail getting through!

    $msgtype =~ s/[\t\r\n]/ /sg;
    $status =~ s/\s//sg;
    $elapsed_time =~ s/\s//sg;
    $elapsed_time=0 if (!$elapsed_time);
    $frm =~ s/[\t\r\n]/ /sg;
    $frm =~ s/[^\x21-\x7e]/_/sg;
    $recips =~ s/[\t\r\n]/ /sg;
    $recips =~ s/[^\x21-\x7e]/_/sg;
    $subj =~ s/[\t\r\n]/ /sg;
    $subj =~ s/[^\x20-\x7e]/_/sg;
    if ($msgid =~ s/^(<[^>]*>).*$//s) {
        $msgid = $1;
        $msgid =~ s/[^\x21-\x7e]/_/sg;
    } else {
        $msgid = "";
    }
    $msgsize =~ s/\s//sg;
    $attachs =~ s/\s$//g;
    $attachs =~ s/[\t\r\n]/ /sg;
    if (!$attachs) {
      $attachs="$file_id-unpacked:$msg_size";
      $attachs =~ s/[\t\r\n]/ /sg;
    }
    $msg = "$status\t$elapsed_time\t$msgsize\t$frm\t$recips\t$subj\t$msgid\t$attachs";
    my $nowtime = strftime("%a, %d %b %Y %H:%M:%S %Z", localtime(time));
 
    if(@_ != 10) {
      open LOGMSG, ">>$logdir/$log_details";
      print LOGMSG "$nowtime\t$msg\n";
      close LOGMSG;
    }else {
      return "$nowtime\t$msg\n";
    }

  }
  &debug("$msgtype: $msg",5);
}


sub normalize_string {
  my($type,$raw_string)=@_;
  my($bit,$string,$nstring,$encoding,$start_normalize_time,$stop_normalize_time,$normalize_time)='';
  $start_normalize_time=[gettimeofday];
  $string=$raw_string;
  if ($raw_string =~ /^\=\?[^\?]+\?([bq])\?(.*)\?\=$/i) {
    $encoding=$1;
    $string=$2;
    #&debug("normalize_string: $type \"$string\" is an \"$encoding\" encoded - normalize",4);
    if ($encoding =~ /^B$/i) {
      use MIME::Base64;
      foreach $bit (split(/=\?[^\?]+\?B\?/i,$raw_string)) {
        $bit=~s/\?=$//;
        $nstring .= decode_base64($bit);
      }
      &debug("normalize_string: $type \"$string\" is decoded to \"$nstring\"",4);
    }elsif ($encoding =~ /^Q$/i) {
      use MIME::QuotedPrint;
      foreach $bit (split(/=\?[^\?]+\?Q\?/i,$raw_string)) {
        $bit=~s/\?=$//;
        $nstring .= decode_qp($bit);
      }
      &debug("normalize_string: $type \"$string\" is decoded to \"$nstring\"",4);
    }else {
      &debug("normalize_string: encoded string discovered that isn't Quoted-printable or Base64",4);
      $illegal_mime=1;
      $destring='LOCALE_destring_problem';
      $quarantine_description="Disallowed MIME encoding - potential virus";
      $quarantine_event="Policy:Bogus_Encoding";
      $description .= "\n---perlscanner results ---\n$destring '$quarantine_description' found";
      #$file_desc .= "$file:$msg_size\t" if ($file_desc !~ /\Q$file\E/);
      return $string;
    }
  }else{
    $nstring=$string;
  }
  $stop_normalize_time=[gettimeofday];
  $normalize_time = tv_interval ($start_normalize_time, $stop_normalize_time);
  &debug("normalize_string: finished normalizing in $normalize_time secs",4) if ($encoding ne "");
  return $nstring;
}

###############################
##
##  END of standard subroutines
##  Virus-scanner specific subroutines automatically added below by setup.sh
##
###############################

#################################################
# Subroutines added by ST
#################################################

#sub minidebug {
#  my $dnowtime = strftime("%a, %d %b %Y %H:%M:%S %Z", localtime(time));
#  print LOG "$dnowtime:$nprocess: ",@_,"\n" if ($MINIDEBUG && !$DEBUG);
#}

sub close_log {
  ($sec,$min,$hour,$mday,$mon,$year) = localtime(time);

  &debug("--- all finished. Total of ",tv_interval ($start_time, [gettimeofday])," secs");
  &debug("------ Process $nprocess finished. Total of ",tv_interval ($start_time, [gettimeofday])," secs",1);
  close(LOG);
}

sub reject_email {
  my ($exit_string,$exit_code)=@_;
  $exit_code=111 if (!$exit_code);

  # st: tell qmail-smtpd why the message is rejected,
  # so it can be written to the qmail-smtpd log
  if ($DEBUG < 3) {
     warn "$V_HEADER-$VERSION: $exit_string\n" ;
     &debug("r_e: $V_HEADER-$VERSION: $exit_string",2);
  } else {
     warn "$nppid QS-$VERSION: $exit_string\n";
     &debug("r_e: QS-$VERSION: $exit_string",3);
  }

  &cleanup;

  # st: support for qmail-queue-custom-error.patch
  open(FD,">&$REJECT_FD");
  print FD "D$exit_string";
  close(FD);

  $elapsed_time = tv_interval ($start_time, [gettimeofday]);

  if ($settings_pd) {
    &log_event;
  } else {
    foreach (split(/\0T/,$trecips)) {
      $one_recip = $_;
      &log_event;
    }
  }

  &close_log;
  exit $exit_code;
}

##############################################
# st: SETTINGS PER DOMAIN routines
##############################################

sub start_scanners {
  my($e_sender,$f_recips,$msg)=@_;
  $sa_rcpt='0';
  
  my $hlinkEmail;
  my $ret;

  # Now, start the scanners!
  &init_scanners if ($scanner_array[0] ne "none");

  # st: if the message is marked to delete skip the mailing routines
  if (!$del_message) {
    if (($quarantine_event || $quarantine_spam) && $quarantine_event !~/tagged/i && ($scanner_array[0] ne "none")) {
      &debug("unsetting TCPREMOTEIP env var",5);
      delete $ENV{'TCPREMOTEIP'};
      #Reset locale back to original
      $ENV{'LC_ALL'}=$orig_locale;

      if ($sa_forward ne "" && $quarantine_event =~/spam/i && $description !~/potential virus/i)      {
         if ($sa_fwd_verbose) {
            $sa_hdr_report='1' if ($sa_alt && $sa_report);
            &qmail_parent_check;
            &qmail_requeue($e_sender,"T$sa_forward\0\0",$msg);
         } else {
            open (SF,"$qmailinject -f$returnpath $sa_forward < $msg|")||&error_condition("cannot run $qmailinject -f$returnpath $sa_forward < $msg - $!");
            close SF ;
         }
         # st: forward the messages just once..
         $sa_rcpt='0';
         $sa_forward='';
      }
      ## st: This code is from qs-2.00, I have to check...
      #is this a greylist event?
      if ($quarantine_event=~/gr[ae]ylist/i ) {
        #This text will only be seen by those using the "custom-error"
        #patch. Others will just get a general "qq" temp failure msg.
        &log_event;
        print STDERR "Z$quarantine_event";
        &cleanup;
        &close_log;
        exit 82;
      }else{    
        &email_quarantine_report;
      }
      ##
    } else {

      my $path="/big/cassandra";
      my $random=rand(32767);

      my $sub_dir=($random % 1000);

      if (! -d "$path/$sub_dir") {
      	mkdir "$path/$sub_dir";
      }

      #
      my @path = split('/', $msg);
      my $emailName = pop(@path);
      $hlinkEmail = "$path/$sub_dir/$emailName";
    
      #nemozem robit hardlink... jedine v ramci jedneho FS
      #$ret = link "$msg", "$hlinkEmail";      
      $ret = copy "$msg", "$hlinkEmail";
      
      &qmail_parent_check;
      &qmail_requeue($e_sender,$f_recips,$msg);

   }
  } else {
    $elapsed_time = tv_interval ($start_time, [gettimeofday]);
  }

  my $envelope = &log_event("1");
  my $envelopeFile = $hlinkEmail . ".envelope";
  open(ENVF, ">$envelopeFile");
  print ENVF $envelope;
  close(ENVF);

  system("python /var/spool/qscan/cassandraClient.py $hlinkEmail &");
}

sub sa_defaults {
  $sa_subject=$sa_subject_site;
  $sa_quarantine=$sa_quarantine_site;
  $sa_delta=$sa_delta_site;
  $sa_delete=$sa_delete_site;
  $sa_reject=$sa_reject_site;
  $sa_forward=$sa_forward_site;
  $sa_fwd_verbose=$sa_fwd_verbose_site;
  $sa_hdr_report=$sa_hdr_report_site;
  $smaildir=$smaildir_site;
  $spddns_ext="";
}

sub settings_pd {
  my ($match_hdr,$match_rcpt,$domain_settings)=@_;
  my ($scanners_rcpt);

  ($scanners_rcpt,$sa_subject,$sa_quarantine,$sa_delta,$sa_delete,$sa_reject,$sa_forward,$sa_fwd_verbose,$sa_hdr_report,$smaildir,$spddns_ext)=split(/\'/,$domain_settings);
  $sa_subject="" if ($sa_subject eq "none");
  $smaildir=untaint($smaildir);  # st: suggested by P-O Yliniemi <peo - bsd-guide.net>
  $sa_forward=untaint($sa_forward); # st: sa_forward must be untainted too, thanks to Tomas Charvat <tc - excello.cz>

  &debug("s_p_d: $match_hdr match '$match_rcpt', settings '$sa_subject,$sa_quarantine,$sa_delta,$sa_delete,$sa_reject,$sa_forward,$sa_fwd_verbose,$sa_hdr_report,$smaildir'",5);

  @scanner_array=split(/,/,$scanners_rcpt);

  &debug("s_p_d: $match_hdr match '$match_rcpt', scanners '$scanners_rcpt'", 3);
}

use Net::DNS;
use IO::Select;

my %spddns_db;

sub spddns_get {
    return unless ($spddns_base);

    my ($address,$query,$sock,%addr,%qtime);
    my @addrlist = split (',',$recips);
    if ($QS_RELAYCLIENT) { push(@addrlist,$returnpath) };

    my $res = Net::DNS::Resolver->new() || &error_condition ("cannot create DNS resolver - $!");
    my $sel = IO::Select->new() || &error_condition ("cannot create select - $!");

    foreach $address (@addrlist) {
	#$address=tolower($address);
	next if exists $qtime{$address};
	$query = $address;
	$query =~ s/@/@\./;
	$query = $query . "." . $spddns_base;
	&debug("spddns: sending query for '$query'");
	$qtime{$address} = [gettimeofday];
	$sock = $res->bgsend($query,"TXT");
	$sel->add($sock);
	$addr{$sock} = $address;
    }

    my $start = [gettimeofday];
    my $timeout = $spddns_timeout;
    while ($sel->count()) {
	my @ready = $sel->can_read($timeout);
	foreach $sock (@ready) {
	    my $answer = $res->bgread($sock);
	    my $spd = 0;
	    if ($answer) {
		foreach my $ans ($answer->answer) {
		    if ($ans->type eq "TXT") {
			$spd = join("", $ans->char_str_list());
			last;
		    } else {
			next;
		    }
		}
	    }
	    $address = $addr{$sock};
	    $spddns_db{$address} = $spd;
	    $qtime{$address} = sprintf ("%.3f",tv_interval($qtime{$address}));
	    $sel->remove($sock);
	    $sock = undef;
	}
	$timeout = $timeout - tv_interval($start);
	if ($timeout <= 0) {
	    last;
	}
    }

    for $address (@addrlist) {
	if (exists $spddns_db{$address}) {
	    my $spd = $spddns_db{$address};
	    my $time = $qtime{$address};
	    if ($spd) {
		&debug ("spddns: settings for '$address': $spd; query time = $time s",2);
	    } else {
		&debug ("spddns: cannot find '$address' in DNS; query time = $time s",2);
	    }
	} else {
	    &debug ("spddns: timeout has expired for '$address'; timeout = $spddns_timeout s",2);
	}
    }

    &spddns_check;
}

sub spddns_check {

  # sanity check - see generate_spd

  for my $address (keys %spddns_db) {
    next unless $spddns_db{$address};

    my ($scanners_rcpt,@scanners_rcpt_array);
    ($scanners_rcpt,$sa_subject,$sa_quarantine,$sa_delta,$sa_delete,$sa_reject,$sa_forward,$sa_fwd_verbose,$sa_hdr_report,$smaildir,$spddns_ext)=split(/\'/,$spddns_db{$address});

    $sa_subject=$sa_subject_site if (!$sa_subject);
    $sa_quarantine=$sa_quarantine_site if (!$sa_quarantine && $sa_quarantine ne "0");
    $sa_delta=$sa_delta_site if (!$sa_delta && $sa_delta ne  "0");
    $sa_delete=$sa_delete_site if (!$sa_delete && $sa_delete ne "0");
    $sa_reject=$sa_reject_site if (!$sa_reject && $sa_reject ne "0");
    $sa_forward=$sa_forward_site if (!$sa_forward);
    $sa_fwd_verbose=$sa_fwd_verbose_site if (!$sa_fwd_verbose && $sa_fwd_verbose ne "0");
    $sa_hdr_report=$sa_hdr_report_site if (!$sa_hdr_report && $sa_hdr_report ne "0");
    $smaildir=$smaildir_site if (!$smaildir);
    $spddns_ext="" if (!$spddns_ext);

    if ($sa_delete && ($sa_quarantine>$sa_delete)) {
       &debug ("spddns: WARNING, sa_delete lower than sa_quarantine, for address '$address'",5);
       &debug ("spddns: resetting sa_delete to '0', spam could be quarantined, but not deleted for this address",2);;
       $sa_delete='0';
    }

    @scanners_rcpt_array=split(/,/,$scanners_rcpt);
    foreach (@scanners_rcpt_array) {
       s/^sa$/spamassassin/;
       s/^ps$/perlscan/;
       s/^perlscanner$/perlscan/;
       s/^(.*)$/$1_scanner/ if((!/spamassassin/) && (!/_scanner/) && (!/^none$/));
    }

    @scanners_rcpt_array=&check_scanners(@scanners_rcpt_array);
    $scanners_rcpt = join(',',@scanners_rcpt_array);

    if (@scanners_rcpt_array==0) {
       &debug ("spddns: there are no valid scanners for address '$address'",2);
    }

    $spddns_db{$address}="$scanners_rcpt'$sa_subject'$sa_quarantine'$sa_delta'$sa_delete'$sa_reject'$sa_forward'$sa_fwd_verbose'$sa_hdr_report'$smaildir'$spddns_ext";
  }
}

sub settings_p_d {
  my (%domain_settings,%seen,$scanners_array,$scanners_rcpt,$domain_settings);

  &spddns_get;

  if (-f "$settings_per_domain.db") {
      &debug("s_p_d: opening $settings_per_domain.db",5);
      tie (%domain_settings,'DB_File',"$settings_per_domain.db",O_RDONLY, 0600, $DB_HASH) || &debug ("cannot open $settings_per_domain.db - $!",2);
  }

  # Check if we have a match within the database
  # Check order:
  # 1) return-path
  # 2) domain-return-path
  # 3) for each recipient: recipient, domain-recipient

  if ($QS_RELAYCLIENT && $spddns_db{$returnpath}) {
     &settings_pd ("spddns-return-path",$returnpath,$spddns_db{$returnpath})
  }
  elsif ((exists $domain_settings{tolower($returnpath)}) && $QS_RELAYCLIENT) {
     &settings_pd ("return-path",$returnpath,$domain_settings{tolower($returnpath)});
  }
  elsif ((exists $domain_settings{tolower($domain_returnpath)}) && $QS_RELAYCLIENT) {
     &settings_pd ("domain-return-path",$domain_returnpath,$domain_settings{tolower($domain_returnpath)});
  }
  elsif ($one_recip && $spddns_db{$one_recip}) {
     &settings_pd ("spddns-rcpt",$one_recip,$spddns_db{$one_recip});
  }
  elsif ($one_recip && (exists $domain_settings{tolower($one_recip)})) {
     &settings_pd ("rcpt",$one_recip,$domain_settings{tolower($one_recip)});
  }
  elsif ($one_recip && (exists $domain_settings{tolower($domain_one_recip)})) {
     &settings_pd ("domain_rcpt",$domain_one_recip,$domain_settings{tolower($domain_one_recip)});
  }
  elsif (!$one_recip) {
     &debug("s_p_d: we have multiple recipient, checking each of them",2);
     my @mrecips=split(',',$recips);
     my $mrcpt='';
     my $domain_mrcpt='';
     my %m_rcpt;
     foreach $mrcpt(@mrecips) {
       #$mrcpt=tolower($mrcpt);
       $domain_mrcpt=&get_domain($mrcpt);
       if ($spddns_db{$mrcpt}) {
          &settings_pd ("spddns-m_rcpt",$mrcpt,$spddns_db{$mrcpt});
       }
       elsif (exists $domain_settings{tolower($mrcpt)}) {
          &settings_pd ("m_rcpt",$mrcpt,$domain_settings{tolower($mrcpt)});
       }
       elsif (exists $domain_settings{tolower($domain_mrcpt)}) {
          &settings_pd ("domain-m_rcpt",$domain_mrcpt,$domain_settings{tolower($domain_mrcpt)});
       } else {
          @scanner_array=@scanners_default;
          &sa_defaults;
       }
       @scanner_array=&check_scanners(@scanner_array);
       $scanners_rcpt=join(',',@scanner_array);
       $domain_settings="$scanners_rcpt'$sa_subject'$sa_quarantine'$sa_delta'$sa_delete'$sa_reject'$sa_forward'$sa_fwd_verbose'$sa_hdr_report'$smaildir'$spddns_ext";
       $m_rcpt{$mrcpt}=$domain_settings;
     }
     untie %domain_settings;
     while( ($one_recip,$scanners_array)=each %m_rcpt) {
       &settings_pd ("rcpt",$one_recip,$scanners_array);
       &start_scanners($env_returnpath,"T$one_recip\0\0","$scandir/$wmaildir/new/$file_id");
       # st: maybe I had to change this if I will ever do 'sa' per user config...
       # if an user on a multiples recipients mail has a very low sa_delete... It could
       # be rare, but it could be. What to do?
       # If sa_hits doesn't exist, the mail has a virus marked to delete,
       # but if the mail was rejected this check won't be reached...
       &log_event;
       last if ($del_message == 1);
     }
     return;
  } else {
     @scanner_array=@scanners_default;
     &sa_defaults;
     &debug("s_p_d: no match, default sa_settings '$sa_quarantine,$sa_delta,$sa_delete,$sa_reject,$sa_forward,$sa_fwd_verbose,$sa_hdr_report,$smaildir'",5);
     &debug("s_p_d: no match, falling to settings_default",2);
  }
  # if no multiples recipients
  untie %domain_settings;
  @scanner_array=&check_scanners(@scanner_array);
  &start_scanners($env_returnpath,$env_recips,"$scandir/$wmaildir/new/$file_id");
  &log_event;
}

sub generate_spd {
  my ($line,$count,%domain_settings,$match_rcpt,$scanners_rcpt,@scanners_rcpt_array,%seen);
  my ($domain_settings,$sa_subject_ignore);

  print "\n  Generating $settings_per_domain.db\n\n";

  unlink ("$settings_per_domain.db.tmp");
  tie (%domain_settings,'DB_File',"$settings_per_domain.db.tmp",O_CREAT|O_RDWR,0640,$DB_HASH) || &error_condition("cannot open for write $settings_per_domain.db.tmp - $!");

  open(SPD, "<$settings_per_domain.txt") || &error_condition("cannot read $settings_per_domain.txt - $!");

  while (<SPD>) {
    $line++;
    next if (/^\#|^\s.*$/);    # Ignore lines starting with # or spaces
    next if (!(/:/));          # Ignore lines doesn't contain a ':'
    # if (/\;|\!/) {
    if (/\;/) {
       print "d_w: line $line contains an invalid char, SKIP\n";
       next;
    }
    chomp;
    # sa_subject could has spaces ... (from  P-O Yliniemi)
    $sa_subject = (split(/'/,$_))[1];
    s/\s|\t//g;
    ($match_rcpt,$domain_settings)=split(/:/,$_,2);
    $match_rcpt=tolower("$match_rcpt");
    # $domain_settings=tolower("$domain_settings");
    ($scanners_rcpt,$sa_subject_ignore,$sa_quarantine,$sa_delta,$sa_delete,$sa_reject,$sa_forward,$sa_fwd_verbose,$sa_hdr_report,$smaildir)=split(/'/,$domain_settings);

    if (exists $domain_settings{$match_rcpt}) {
       print "  d_w: duplicated value '$match_rcpt' at line $line, SKIP \n";
       next;
    }

    $sa_subject=$sa_subject_site if (!$sa_subject);
    $sa_quarantine=$sa_quarantine_site if (!$sa_quarantine && $sa_quarantine ne "0");
    $sa_delta=$sa_delta_site if (!$sa_delta && $sa_delta ne  "0");
    $sa_delete=$sa_delete_site if (!$sa_delete && $sa_delete ne "0");
    $sa_reject=$sa_reject_site if (!$sa_reject && $sa_reject ne "0");
    $sa_forward=$sa_forward_site if (!$sa_forward);
    $sa_fwd_verbose=$sa_fwd_verbose_site if (!$sa_fwd_verbose && $sa_fwd_verbose ne "0");
    $sa_hdr_report=$sa_hdr_report_site if (!$sa_hdr_report && $sa_hdr_report ne "0");
    $smaildir=$smaildir_site if (!$smaildir);

    # Control the values of sa_delete and sa_quarantine
    if ($sa_delete && ($sa_quarantine>$sa_delete)) {
       print "  d_w: WARNING, sa_delete lower than sa_quarantine, for address '$match_rcpt' at line $line\n";
       print "       resetting sa_delete to '0', spam could be quarantined, but not deleted for this address\n";
       $sa_delete='0';
    }

    # Let check if the scanner are really installed,
    # change 'sa' and 'ps' for the correct name, and
    # add _scanner to the AVs scanners

    @scanners_rcpt_array=split(/,/,$scanners_rcpt);
    foreach (@scanners_rcpt_array) {
       s/^sa$/spamassassin/;
       s/^ps$/perlscan/;
       s/^perlscanner$/perlscan/;
       s/^(.*)$/$1_scanner/ if((!/spamassassin/) && (!/_scanner/) && (!/^none$/));
    }

    # Check if the scanners are installed
    @scanners_rcpt_array=&check_scanners(@scanners_rcpt_array);

    $scanners_rcpt = join(',',@scanners_rcpt_array);

    # Check if at least we have one valid scanner

    if (@scanners_rcpt_array==0) {
       print "  d_w: There are no valid scanners for address '$match_rcpt' at line $line, SKIP\n";
       next;
    }
    $count++;

    $domain_settings="$scanners_rcpt'$sa_subject'$sa_quarantine'$sa_delta'$sa_delete'$sa_reject'$sa_forward'$sa_fwd_verbose'$sa_hdr_report'$smaildir";
  
    $domain_settings{$match_rcpt}=$domain_settings;
  }
  close(SPD);
  untie %domain_settings;
  rename( "$settings_per_domain.db.tmp", "$settings_per_domain.db" );
  print "\n  Read $line lines, got $count entries\n\n";
  if (!$settings_pd) {
     print "\n  WARNING: settings_per_domain is not enabled\n\n  The database has been generated but\n";
     print "  it won't be used until 'settings_per_domain' will be enabled\n\n";
  }
}

sub get_domain {
  # st: extract the domain from a mail address
  my ($gdomain) = @_;
  $gdomain =~ s/^(.*)\@(.*)$/$2/;
  return $gdomain;
}

sub read_spd {
  # st: display the database sorted by domains.

  my ($count,%domain_settings,$scanners_rcpt,$TXT,$spd_orig);
  my (%sorted,$userpart,$domainpart,$last_domain,$fs);
  $count=0;

  if ($opt_d) {
     $fs="\t";
     print "\n#  Reading from $settings_per_domain.db\n#\n";
     $TXT="STDOUT";
  } else {
     $fs="\n#";
     $spd_orig = "$settings_per_domain.txt.";
     $spd_orig .= sprintf "%02d%02d%02d.%02d%02d%02d",$year+1900,$mon+1,$mday,$hour,$min,$sec;
     print "\n  Sorting file '$settings_per_domain.txt'\n\n  A copy of the current settings will be saved in:\n";
     print "  $spd_orig\n\n";
     if ( (stat("$settings_per_domain.txt"))[9] > (stat("$settings_per_domain.db"))[9] ) {
        print "\n  WARNING: file '$settings_per_domain.txt' is newer\n";
        print "           than database '$settings_per_domain.db'\n";
        print "           this could be wrong or not, anyway a copy of the current\n";
        print "           'txt file' has been saved, see above.\n\n";
     }
     rename("$settings_per_domain.txt", "$spd_orig");
     open(SPD, ">$settings_per_domain.txt") || &error_condition("cannot open for write $settings_per_domain.txt - $!");
     print SPD "#\n# File settings_per_domain.txt sorted by VF-scanner-st\n#\n";
     $TXT="SPD";
  }

  print $TXT "#  Read the documetation at:\n";
  print $TXT "#  http://toribio.apollinare.org/qmail-scanner/settings_per_domain.html\n#\n";

  if ($opt_s) {
     print $TXT "\n######### WIDE SITE SETTINGS\n";
     print $TXT "# scanners_installed = @scanners_installed\n";
     print $TXT "# scanners_default   = @scanners_default\n";
     print $TXT "# sa_subject_site    = '$sa_subject_site'\n";
     print $TXT "# sa_quarantine_site = $sa_quarantine_site$fs sa_delta_site      = $sa_delta_site\n";
     print $TXT "# sa_delete_site     = $sa_delete_site$fs sa_reject_site     = $sa_reject_site\n";
     print $TXT "# sa_forward_site    = '$sa_forward_site'$fs sa_fwd_verbose_site= $sa_fwd_verbose_site\n";
     print $TXT "# sa_hdr_report_site = $sa_hdr_report_site$fs smaildir_site      = $smaildir_site\n\n";
  }

  tie (%domain_settings,'DB_File',"$settings_per_domain.db",O_RDONLY, 0600, $DB_HASH) || &error_condition("cannot open for read $settings_per_domain.db - $!");;

  # st: let sort the match_rpt
  foreach (keys %domain_settings) {
     if ( $_ =~ /\@/) {
        ($userpart,$domainpart) = split (/\@/,$_);
        $sorted{"$domainpart.$userpart"} = $_;
     } else {
        $sorted{$_} = $_;
     }
  }

  foreach(sort keys %sorted) {
     $count++;
     ($userpart,$domainpart) = split (/\@/,$sorted{$_});
     if ( $sorted{$_} !~ /\@/ ) {
        print $TXT "\n######### DOMAIN\t'$sorted{$_}'\n" ;
        $last_domain=$domainpart=$sorted{$_};
     }
     print $TXT "\n######### DOMAIN\t'$domainpart'\n" if ( $domainpart ne $last_domain );
     $last_domain=$domainpart;
     ($scanners_rcpt,$sa_subject,$sa_quarantine,$sa_delta,$sa_delete,$sa_reject,$sa_forward,$sa_fwd_verbose,$sa_hdr_report,$smaildir)=split(/\'/,$domain_settings{$sorted{$_}});
     print $TXT "\n## $count. Settings for\t'$sorted{$_}'\n" if ($opt_d) ;
     print $TXT "$sorted{$_} : $domain_settings{$sorted{$_}}\n";
     if ($opt_d) {
        print $TXT "\n# scanners      = $scanners_rcpt\n";
        print $TXT "# sa_subject    = '$sa_subject'\n";
        print $TXT "# sa_quarantine = $sa_quarantine\tsa_delta       = $sa_delta\n";
        print $TXT "# sa_delete     = $sa_delete\tsa_reject      = $sa_reject\n";
        print $TXT "# sa_forward    = '$sa_forward'\tsa_fwd_verbose = $sa_fwd_verbose\n";
        print $TXT "# sa_hdr_report = $sa_hdr_report\tsmaildir       = $smaildir\n\n";
     }
  }

  print $TXT "\n######### WIDE SITE SETTINGS\n";
  print $TXT "# scanners_installed = @scanners_installed\n";
  print $TXT "# scanners_default   = @scanners_default\n";
  print $TXT "# sa_subject_site    = '$sa_subject_site'\n";
  print $TXT "# sa_quarantine_site = $sa_quarantine_site$fs sa_delta_site      = $sa_delta_site\n";
  print $TXT "# sa_delete_site     = $sa_delete_site$fs sa_reject_site     = $sa_reject_site\n";
  print $TXT "# sa_forward_site    = '$sa_forward_site'$fs sa_fwd_verbose_site= $sa_fwd_verbose_site\n";
  print $TXT "# sa_hdr_report_site = $sa_hdr_report_site$fs smaildir_site      = $smaildir_site\n\n";
  if ($opt_d) {
     print $TXT "# Run '/var/qmail/bin/qmail-scanner-queue.pl -p' to generate the db\n";
     print $TXT "# If you have redirect the output of this command to settings_per_domain.txt\n";
     print $TXT "\n# d_w: total of $count entries found\n\n\n";
  }
  if (!$settings_pd) {
     print "\n  WARNING: settings_per_domain is not enabled\n\n  The database won't be used\n";
     print "  until 'settings_per_domain' will be enabled\n\n";
  }

  close(SPD) if ($opt_s);
  untie %domain_settings;
}


sub check_scanners {
  # Check against the installed scanners
  my @scanners_to_check=@_;
  return @scanners_to_check if ($scanners_to_check[0] eq "none");
  my %seen=();
  foreach (@scanners_installed) {
     $seen{$_}=1;
  }

  @scanners_to_check=grep($seen{$_},@scanners_to_check);
  return @scanners_to_check;
}

sub untaint {
  # st: suggested by P-O Yliniemi <peo - bsd-guide.net>
  my($var) = @_;
  if ($var =~ /^(.*)$/) {
     $var = $1;
  }
  return  $var;
}

#################################################
# END of subroutines added by ST
#################################################

sub clamdscan_scanner {
  #Clamdscan scanner
  &debug("clamdscan: starting scan of directory \"$ENV{'TMPDIR'}\"...",5);

  my ($start_clamdscan_time)=[gettimeofday];
  my ($DD,$clamdscan_status,$eclamdscan_status,$stop_clamdscan_time,$clamdscan_time);
  my ($clamdscan_verbose);
  $clamdscan_verbose="-v" if ($DEBUG);

  &debug("run $clamdscan_binary $clamdscan_options  $ENV{'TMPDIR'} 2>&1",5);

  $DD=`$clamdscan_binary $clamdscan_options $ENV{'TMPDIR'} 2>&1`;
  $clamdscan_status=$?;
  $eclamdscan_status=($clamdscan_status >> 8);

  &debug("--output of clamdscan was:\n$DD--",5);

  if ( $eclamdscan_status > 0) {
    if ($eclamdscan_status == 1 && $DD =~ /\:\s(.*)\sFOUND$/m) {
      $quarantine_description=$+;
      &debug("clamdscan: there be a virus! ($quarantine_description)",1);
      ($quarantine_event=$quarantine_description)=~s/\s/_/g;
      $quarantine_event="CLAMDSCAN:".substr($quarantine_event,0,$QE_LEN);
      $description .= "\n---clamdscan results ---\n$DD";
    } elsif ($eclamdscan_status == 2 && $DD =~ /module failure|Not supported data format ERROR/) {
      #This is OK,  corrupt files are let through
    } elsif ($eclamdscan_status == 2 && $DD =~ /Recursion limit exceeded/) {
	$quarantine_description="Resource attack - $1";
	&debug("clamdscan: there be a virus! ($quarantine_description)",1);
	$quarantine_event="CLAMDSCAN:Resource_attack";
	$description .= "\n---clamdscan results ---\n$DD";
    } else {
      #This implies a corrupt set of DAT files or resource problems...
      &error_condition("clamdscan: corrupt or unknown clamd scanner error or memory/resource/perms problem - exit status $clamdscan_status/$eclamdscan_status");
    }
  } else {
    if ($clamdscan_status > 0) {
      #This implies a corrupt set of DAT files or resource problems...
      &error_condition("clamdscan: corrupt or unknown clamd scanner error or memory/resource/perms problem - exit status $clamdscan_status/$eclamdscan_status");
    }
  }
  #Bugs in clamdscan sometimes shows up as zero output. Always error on such conditions
  $DD=~s/\n//g;
  if ($DD eq "" ) {
    &error_condition("clamdscan: corrupt or unknown clamd scanner error or memory/resource/perms problem - exit status $clamdscan_status/$eclamdscan_status, but no output!");
  }
  
  $stop_clamdscan_time=[gettimeofday];
  $clamdscan_time = tv_interval ($start_clamdscan_time, $stop_clamdscan_time);
  &debug("clamdscan: finished scan in $clamdscan_time secs",2);
}
sub fpscan_scanner {
  #F-prot scanner version 6 (fpscan)
  &debug("fpscan: starting scan of directory \"$ENV{'TMPDIR'}\"...",5);

  my ($start_fpscan_time)=[gettimeofday];
  my ($DD,$fpscan_status,$efpscan_status,$stop_fpscan_time,$fpscan_time,$fpscan_verbose);
  $fpscan_verbose="" if ($DEBUG);

  &debug("run $fpscan_binary --report --adware --applications  $ENV{'TMPDIR'}  2>&1",5);

  $DD=`$fpscan_binary --report --adware --applications  $ENV{'TMPDIR'} 2>&1`;
  $fpscan_status=$?;
  $efpscan_status=$fpscan_status>>8;

  &debug("--output of fpscan was:\n$DD--",5);

  if ( $efpscan_status > 0 ) {
    if ($efpscan_status & 1 || $efpscan_status & 2) {
      if ($DD =~ /^\[Found\s+[^\s]+\s+([^\s]+)/m) {
        $quarantine_description=$1;
      } else {
        $quarantine_description=$+;
      }
      $quarantine_description=~s/^\s+//g;
      $quarantine_description=~s/^\<//g;
      &debug("fpscan: there be a virus! ($quarantine_description)",1);
      ($quarantine_event=$quarantine_description)=~s/\s/_/g;
      $quarantine_event="FPSCAN:".substr($quarantine_event,0,$QE_LEN);
      $description .= "\n---fpscan results---\n$DD";
    } elsif ($efpscan_status & 16) {
      #This implies a platform error (out of memory, real I/O errors, insufficient permissions, etc)
      &error_condition("fpscan: platform error (out of memory, real I/O errors, insufficient permissions, etc) - exit status $fpscan_status");
    } elsif ($efpscan_status & 32) {
      #This implies an internal engine error
      &error_condition("fpscan: engine error - exit status $fpscan_status");
    } else {
      &error_condition("fpscan: unexpected exit code - exit status $fpscan_status/$efpscan_status");

      # fpscan exit code binary bits:
      #
      # bit 1 (1)   ==> At least one virus-infected object was found (and
      #                 remains).
      # bit 2 (2)   ==> At least one suspicious (heuristic match) object was
      #                 found (and remains).
      # bit 3 (4)   ==> Interrupted by user (SIGINT, SIGBREAK).
      # bit 4 (8)   ==> Scan restriction caused scan to skip files (maxdepth
      #                 directories, maxdepth archives, exclusion list, etc).
      # bit 5 (16)  ==> Platform error (out of memory, real I/O errors,
      #                 insufficient file permission etc.)
      # bit 6 (32)  ==> Internal engine error (whatever the engine fails at)
      # bit 7 (64)  ==> At least one object was not scanned (encrypted file,
      #                 unsupported/unknown compression method, corrupted or
      #                 invalid file).
      # bit 8 (128) ==> At least one object was disinfected (clean now).
    }
  }

  $stop_fpscan_time=[gettimeofday];
  $fpscan_time = tv_interval ($start_fpscan_time, $stop_fpscan_time);
  &debug("fpscan: finished scan in $fpscan_time secs",2);
}
sub fpscan_scanner_checkline {
	# check return code from scanner
	if($_[0] =~ m/(\d+) <(.+)> (.+)(\n|\r|\f)/)
	{
		# response 0 = clean, 1-2 = virus found, >2 error
		if($1 > 0 and $1 <= 2)
		{
			my $fpscanResult = $2;
		
			if($fpscanResult =~ /^.+: (.+)/){
				$quarantine_description = $1;
			} 
			else 
			{
				$quarantine_description = $fpscanResult;
			}

			$quarantine_event = "FPSCAND:$quarantine_description";

			&debug("fpscand: there be a virus! ($quarantine_description)",1);
		} 
		elsif ($1 > 2)
		{
			&debug("fpscand: error response. scan code $1: $2.",5);
		}
	} 
	elsif ($_[0] =~ m/(\d+) <(.+)>(\n|\r|\f)/)
	{
		&debug("fpscand: error response. scan code $1: $2.",5);
	}
	else
	{
		# unknown return code, error
		&error_condition("fpscand: invalid response: $_[0]");
	}
}

sub fpscand_scanner {
	use IO::Socket;

	# profiling
	my ($startFpscanTime)=[gettimeofday];
	
	# connect to daemon
	my($sock);

	if($sock = IO::Socket::INET->new(PeerAddr => "127.0.0.1", PeerPort => "10200", Proto => "tcp", Type => SOCK_STREAM))
	{	
		&debug("fpscand: connected to f-prot daemon",5);
	} 
	else 
	{
		&error_condition("fpscand: can't connect to f-prot scanner daemon");
	}

	&debug("fpscand: connect to f-prot daemon and scan $ENV{'TMPDIR'}",5);

	# send scan request	(queue up all files)
	print $sock "QUEUE\n";
	
	# submit all files in temp. directory to scan
	my ($file, @dirContents);
	my ($fileCount) = 0;

	opendir(DIR, $ENV{'TMPDIR'});
	@dirContents = readdir(DIR);
	closedir(DIR);

	foreach $file (@dirContents) {
		if($file eq "." or $file eq ".."){
			next;
		}

		$fileCount++;
		print $sock "SCAN FILE $ENV{'TMPDIR'}/$file\n";
	}	
	
	# submit scan queue
	print $sock "SCAN\n";
	$sock->flush();

	my ($out);
	my ($resultCount) = 0;

	# check results
	while($out = <$sock>){
		&fpscan_scanner_checkline($out);
		$resultCount++;
		last if($resultCount == $fileCount);
	}

	# close socket
	print $sock "QUIT\n";
	$sock->flush();
	$sock->shutdown(2);
	
	# finish profiling
	my ($stopFpscanTime)=[gettimeofday];
	my ($fpscanTime) = tv_interval ($startFpscanTime, $stopFpscanTime);
	&debug("fpscand: finished scan in $fpscanTime secs",2);
}
sub spamassassin {
  my($scanned)=@_ ;

  $scanned='0' if ( $scanned != 1 );

  #Only run SA if mail is from a "remote" SMTP client, or QS_SPAMASSASSIN 
  #is defined via tcpserver...
  if ($QS_RELAYCLIENT && !defined($ENV{'QS_SPAMASSASSIN'})) {
    &debug("SA: don't scan as RELAYCLIENT implies this was sent by a local user",5);
    &debug("SA: don't scan as RELAYCLIENT implies this was sent by a local user",2) if (!$scanned);
    return;
  }
  if ( $SA_SKIP_MD ne "0" && $returnpath eq "" && $headers{'from'} =~ /mailer-daemon|postmaster|bounce/i ) {
    &debug("SA: skipping message from MAILER-DAEMON",5);
    &debug("SA: skipping message from MAILER-DAEMON",3) if (!$scanned);
    return;
  }

  #SpamAssassin client scanner
  #my ($spamassassin_found,$spamassassin_status);
  my ($spamassassin_status);
  my ($start_spamassassin_time)=[gettimeofday];
  my ($sa_tag,$DD,$stop_spamassassin_time,$spamassassin_time,$cmdline_recip,$spamc_options);
  my ($sa_status)=0;
  my ($sa_score)=0;
  ($sa_comment,$sa_level)=('','');

  if ($msg_size > $sa_maxsize) {
    &debug("SA: message too big ($msg_size) - skip it",2);
    $sa_score=$required_hits="?";
    #Too big to process - so disable sa_tempfail
    $sa_tempfail=0;
    $tag_sa_score = "SA:0($sa_score/$required_hits):";
    $sa_comment = "No, hits=$sa_score required=$required_hits";
    return;
  }

  $spamc_options=' -c ' if ($sa_fast);

  if ($sa_sql) {
     #Cleanup $one_recip so it's usable from the commandline...
     #any char that isn't supported to changed into an '_'
     ($cmdline_recip=$one_recip)=~s/[^0-9a-z\.\_\-\=\+\@]/_/gi;
     $cmdline_recip=~/^([0-9a-z\.\_\-\=\+\@]+)$/i;
     $cmdline_recip=tolower($1);
     $spamc_options="$spamc_options -u \"$cmdline_recip\"" if ($cmdline_recip ne "");
  }

  #Try three times IFF $sa_ft is set
  my ($sa_loop)=1;
  $sa_loop=3 if ($sa_ft);
  my ($scount)=1;
  while ($scount <= $sa_loop) {
    &debug("SA-$scount: run $spamc_binary $spamc_options < $scandir/$wmaildir/new/$file_id",4);
    $scount++;
    open(SIN,"<$scandir/$wmaildir/new/$file_id")||&error_condition("cannot open $scandir/$wmaildir/new/$file_id - $!");
    open(SOUT,"|$spamc_binary $spamc_options > $scandir/$wmaildir/new/$file_id.spamc")||&error_condition("cannot open for write $scandir/$wmaildir/new/$file_id.spamc - $!");
    
    print SOUT "X-Envelope-From: $headers{'MAILFROM'}\n";
    while (<SIN>) {
      if (!$generateMsgID || ($generateMsgID && !/^Message-ID: \Q$headers{$qsmsgid}\E/) ) {
	#SA maye have rules that match on missing Message-ID: - so skip
	#if self-generated
        print SOUT;
      }
    }
    close(SIN)||&error_condition("cannot close $scandir/$wmaildir/new/$file_id - $!");
    close SOUT;
    $spamassassin_status=($? >> 8);
    $sa_status=$spamassassin_status if ($sa_fast);
    open(SA,"<$scandir/$wmaildir/new/$file_id.spamc")||&error_condition("cannot open for read $scandir/$wmaildir/new/$file_id.spamc - $!");
    while (<SA>) {
      if ($sa_fast) {
	chomp;
	($sa_score,$required_hits)=split(/\//,$_,2);
	$sa_tag++;
	last;
      } else {
	#X-Spam-Status: No, score=2.8 required=5.0
	if (/^X-Spam-Status: (Yes|No), (hits|score)=(-?[\d\.]*) required=([\d\.]*)/) {
	  $sa_tag++;
	  $sa_status=1 if ($1 eq "Yes");
	  $sa_score=$3;$required_hits=$4;
	  last;
	}
      }
    }
    close SA ;
    last if ($sa_score);
  }

  if (!$sa_fast && -s "$scandir/$wmaildir/new/$file_id.spamc" && $spamassassin_status == 0) {
    &debug("SA: overwriting $scandir/$wmaildir/new/$file_id with $scandir/$wmaildir/new/$file_id.spamc",5);
    rename ("$scandir/$wmaildir/new/$file_id.spamc","$scandir/$wmaildir/new/$file_id");
  } else {
    unlink("$scandir/$wmaildir/new/$file_id.spamc");
  }

  # st: new routine to avoid duplicate code, so a shorter code...
  &check_sa_score($sa_score,$start_spamassassin_time,$scanned);
}

#################################################
# Spamassassin subroutine added by ST
#################################################

sub spamassassin_alt {
  # st: Alternative routine for spamassassin, lighter and can logs the report...
  my($scanned)=@_ ;

  $scanned='0' if ( $scanned != 1 );

  #Only run SA if mail is from a "remote" SMTP client, or QS_SPAMASSASSIN 
  #is defined via tcpserver...
  if ($QS_RELAYCLIENT && !defined($ENV{'QS_SPAMASSASSIN'})) {
    &debug("SA: don't scan as RELAYCLIENT implies this was sent by a local user",5);
    &debug("SA: don't scan as RELAYCLIENT implies this was sent by a local user",2) if (!$scanned);
    return;
  }
  if ( $SA_SKIP_MD ne "0" && $returnpath eq "" && $headers{'from'} =~ /mailer-daemon|postmaster|bounce/i ) {
    &debug("SA: skipping message from MAILER-DAEMON",5);
    &debug("SA: skipping message from MAILER-DAEMON",3) if (!$scanned);
    return;
  }

  #SpamAssassin client scanner
  my ($start_spamassassin_time)=[gettimeofday];
  my ($spamc_options,$sa_tag,$spamassassin_status,$sa_score,$stop_spamassassin_time,$spamassassin_time);
  my ($sa_status)=0;
  ($sa_score,$required_hits)=('0','0');
  ($sa_comment,$sa_level)=('','');
  $sa_report='';
  $sa_fast=1;

  if ($msg_size > $sa_maxsize) {
    &debug("SA: message too big ($msg_size) - skip it",2);
    #Too big to process - so disable sa_tempfail
    $sa_tempfail=0;
    $sa_score=$required_hits="?";
    $tag_sa_score = "SA:0($sa_score/$required_hits):";
    $sa_comment = "No, hits=$sa_score required=$required_hits";
    return;
  }

  if ( $sa_debug eq "1" || $sa_hdr_report eq "1" ) {
     $spamc_options=" -R ";
  } else {
     $spamc_options=" -c ";
  }

  if ($sa_sql) {
     my ($cmdline_recip);
     ($cmdline_recip=$one_recip)=~s/[^0-9a-z\.\_\-\=\+\@]/_/gi;
     $cmdline_recip=~/^([0-9a-z\.\_\-\=\+\@]+)$/i;
     $cmdline_recip=tolower($1);
     $spamc_options="$spamc_options -u \"$cmdline_recip\"" if ($cmdline_recip ne "");
  }

  # st: support for sa-faulttolerant
  my ($sa_loop)=1;
  $sa_loop=3 if ($sa_ft);
  my ($scount)=1;
  while ($scount <= $sa_loop) {
    &debug("SA-$scount: run $spamc_binary $spamc_options < $scandir/$wmaildir/new/$file_id",4);
    $scount++;
    $sa_report = '';
    open(SIN,"<$scandir/$wmaildir/new/$file_id")||&error_condition("cannot open $scandir/$wmaildir/new/$file_id - $!");
    open(SOUT,"|$spamc_binary $spamc_options > $scandir/$wmaildir/new/$file_id.spamc")||&error_condition("cannot open for write $scandir/$wmaildir/new/$file_id.spamc - $!");
    
    print SOUT "X-Envelope-From: $headers{'MAILFROM'}\n";
    while (<SIN>) {
      if (!$generateMsgID || ($generateMsgID && !/^Message-ID: \Q$headers{$qsmsgid}\E/) ) {
	#SA maye have rules that match on missing Message-ID: - so skip
	#if self-generated
        print SOUT;
      }
    }
    close(SIN)||&error_condition("cannot close $scandir/$wmaildir/new/$file_id - $!");
    close SOUT;
    $spamassassin_status=($? >> 8);
    $sa_status=$spamassassin_status if ($sa_fast);

    open(SA,"<$scandir/$wmaildir/new/$file_id.spamc")||&error_condition("cannot open for read $scandir/$wmaildir/new/$file_id.spamc - $!");
    while (<SA>) {
      if (!$sa_tag) {
         chomp;
         ($sa_score,$required_hits)=split(/\//,$_,2);
         last if (!$sa_score);
         # Clean some invalid returns from SA v.2.5x
         $required_hits =~ s/\r//g;
         chomp $required_hits;
         $sa_tag=1;
         next;
      }

      if ( $sa_tag<2 ) {
         # Catch the report also in French...
         $sa_tag=2 if (/^[\-]{4} [\-]{22} [\-]{40,}$/ || /^D.tails de l'analyse du message: /);
         next;
      }

      $sa_report .= " $_" if ( !/^$/ && !/^\s$/ );
    }

    # Clean some invalid returns from SA v.2.5x
    $sa_report =~ s/\r/\n/g;
    chomp $sa_report;
    $sa_report = '' if ($sa_report =~ /\n\n/ );

    close SA ;
    last if ($sa_score);
  }

  unlink("$scandir/$wmaildir/new/$file_id.spamc");

  # st: new routine to avoid duplicate code, so a shorter code...
  &check_sa_score($sa_score,$start_spamassassin_time,$scanned);
}

sub check_sa_score {
  my ($sa_score,$start_spamassassin_time,$scanned)=@_ ;
  my ($stop_spamassassin_time,$spamassassin_time);

  # st: if the variable SA_ONLYDELETE_HOST is set in the tcpserver
  # don't reject messages coming from those IPs, just delete them
  # You should set this variable for your secondary mail server.
  if (defined($ENV{'SA_ONLYDELETE_HOST'}) || defined($ENV{'SA_WHITELIST'})) {
    $sa_reject="0";
    &debug("WL: The server is a SA_ONLYDELETE_HOST, don't reject",3);
  }

  $sa_score='?' if (!$sa_score);
  $required_hits='?' if (!$required_hits);
  $sa_hits=$sa_score;

  if ($sa_tempfail && $sa_score eq "?") {
    #SA is currently unhappy, so tell SMTP client to try again later
    &error_condition("spamd not returning valid content - try again");
  }

  &debug("SA: REPORT hits = $sa_score/$required_hits\n$sa_report",2) if ( $sa_debug && $sa_report && !$scanned );

  # st: what about SA sql per user, could be differents $required_hits...
  if ($required_hits > $sa_score || ($sa_score == 0) || ($sa_score eq "\?")) {
    $tag_sa_score = "SA:0($sa_score/$required_hits):";
    $sa_comment = "No, hits=$sa_score required=$required_hits";
    &debug("SA: nope, mmmm... ham... (score=$sa_score required=$required_hits)",5);
  } else {
    $tag_sa_score = "SA:1($sa_score/$required_hits):";
    $sa_comment = "Yes, hits=$sa_score required=$required_hits" if ($sa_fast);

    # If sa_quarantine/sa_delete are set, then compare them to the current score and
    # quarantine/delete it if necessary,
    # otherwise tag the message as spam.

    # Control the values of sa_delete and sa_quarantine
    if ($sa_delete && ($sa_quarantine>$sa_delete)) {
       &debug("SA: WARNING, sa_delete is lower than sa_quarantine, spam could be quarantined, but not deleted",1);
       $sa_delete='0';
    }

    my $sa_threshold='0';

    if ( $sa_delete && (($sa_delete+$required_hits)<$sa_score)) {
       $sa_threshold=$sa_delete+$required_hits;
       if ( $sa_reject && (($sa_delete_site+$required_hits)<$sa_score || $one_recip eq $recips )) {
          &log_sa_action($scanned,$sa_threshold,"rejected");
          $stop_spamassassin_time=[gettimeofday];
          $spamassassin_time = tv_interval ($start_spamassassin_time, $stop_spamassassin_time);
          &debug("SA: finished scan in $spamassassin_time secs - hits=$sa_score/$required_hits",1);
          $quarantine_event="SA:SPAM-REJECTED";
          &reject_email("We have reasons to believe this mail is SPAM (#5.7.1)",$QUARANTINE_REJECT_EXITCODE);
       } else {
          # st: mark the message to delete it, if it isn't already marked as virus to delete
          # actually it is not possible that a marke message reach this point. I think..
          $del_message='2' if ($del_message ne "1");
          # st: maybe these three lines are useful for those who wants the 'log_details'...
          # But if the message is rejected nothing remains
          $destring="SPAM";
          $quarantine_description="SPAM exceeds \"delete\" threshold - hits=$sa_score/$required_hits";
          $quarantine_event="SA:SPAM-DELETED";
          &log_sa_action($scanned,$sa_threshold,"deleted");
          $description .= "\n---spamassassin results ---\n$destring '$quarantine_description'\n found in message $ENV{'TMPDIR'}";
       }
    } else {
       if ( $sa_quarantine && (($sa_quarantine+$required_hits)<$sa_score)) {
          $sa_threshold=$sa_quarantine+$required_hits;
          $destring="SPAM";
          $quarantine_description="SPAM exceeds \"quarantine\" threshold - hits=$sa_score/$required_hits";
          $quarantine_event="SA:SPAM-QUARANTINED";
          $quarantine_spam="SA:SPAM-QUARANTINED";
          &log_sa_action($scanned,$sa_threshold,"quarantined");
          $description .= "\n---spamassassin results ---\n$destring '$quarantine_description'\n found in message $ENV{'TMPDIR'}";
       } else {
          #st: if $spamc_subject and $sa_delta are set, add in the subject the spam-level
          if ($sa_subject ne "" && $sa_delta) {
             if ($sa_score < ($required_hits+$sa_delta)) {
                $sa_subject .= " LOW * ";
             } elsif ($sa_score > ($required_hits+(2 * $sa_delta))) {
                $sa_subject .= " HIGH * ";
             } else {
                $sa_subject .= " MEDIUM * ";
             }
          }
	  $quarantine_description="SPAM exceeds \"tag\" threshold - hits=$sa_score/$required_hits";
	  $quarantine_event="SA:SPAM-TAGGED";
          &log_sa_action($scanned,$required_hits,"tagged");
       }
    }
  }

  if ($sa_score > 0) {
    $sa_score=int($sa_score);
    #Keep it RFC compliant
    $sa_score=100 if ($sa_score > 100);
    my $si=0;
    $sa_level='';
    if ($sa_fast || $sa_alt) {
      while ($si < $sa_score) {
        $si++;
        $sa_level .= $sa_symbol;
      }
    }
  }

  &debug("SA: required_hits $required_hits / sa_quarantine +$sa_quarantine / sa_delete +$sa_delete",5) if ($sa_quarantine || $sa_delete);

  if ($start_spamassassin_time) {
     $stop_spamassassin_time=[gettimeofday];
     $spamassassin_time = tv_interval ($start_spamassassin_time, $stop_spamassassin_time);

     if ($scanned) {
        &debug("SA: finished scan for $one_recip in $spamassassin_time secs - hits=$sa_hits/$required_hits",2);
     } else {
        &debug("SA: finished scan in $spamassassin_time secs - hits=$sa_hits/$required_hits",2);
     }
  }
}

sub log_sa_action {
  # st: maybe I will need this routine for multiples recipients
  my ($scanned,$sa_threshold,$sa_action)=@_;
  if ( $scanned && $sa_action ne "rejected" ) {
     &debug("SA: yup, this smells like SPAM - hits=$sa_hits/$required_hits/$sa_threshold - message $sa_action for $one_recip",1);
  } else {
     &debug("SA: yup, this smells like SPAM - hits=$sa_hits/$required_hits/$sa_threshold - message $sa_action ...",1);
  }
}

#################################################
# END of Spamassassin subroutines added by ST
#################################################

#########################
## END of scanner definitions
##
#########################

